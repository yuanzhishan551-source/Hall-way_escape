<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corridor Flashlight Escape</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 16px;
            z-index: 100;
            text-shadow: 0 0 10px #00ff00;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #00ff00;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }
        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }
        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="loading">Loading...</div>
    <div id="crosshair"></div>
    <div id="ui-overlay">
        <div id="instructions">
            WASD: Move<br>
            MOUSE: Look Around<br>
            ESC: Unlock Mouse
        </div>
    </div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        window.addEventListener('load', function() {
            init();
        });

        function init() {
            // Scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.Fog(0x000000, 10, 50);

            // Camera (first person)
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 0); // Eye level

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            document.getElementById('loading').style.display = 'none';

            // Create text texture (from reference code)
            function createTextTexture(text, width = 2048, height = 2048) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, width, height);

                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 28px Courier New';

                const words = text.split(' ');
                let y = 40;
                let x = 20;

                while (y < height - 40) {
                    const word = words[Math.floor(Math.random() * words.length)];
                    const metrics = ctx.measureText(word);

                    if (x + metrics.width > width - 40) {
                        x = 20;
                        y += 50;
                    }

                    ctx.fillText(word, x, y);
                    x += metrics.width + 25;
                }

                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                return texture;
            }

            // Sample text with warnings
            const wallText = `RUN ESCAPE DANGER GET OUT FLEE WARNING EXIT HURRY # | / \\ - + = * : . X H M W N data information technology digital world artificial intelligence machine learning algorithm code programming software development`;

            // Create corridor with proper texture repeat for each face
            const textTexture = createTextTexture(wallText);

            // Create separate materials for each face with proper repeat
            const materials = [];

            // Right wall (long wall: 500 length x 4 height)
            const rightTexture = textTexture.clone();
            rightTexture.wrapS = THREE.RepeatWrapping;
            rightTexture.wrapT = THREE.RepeatWrapping;
            rightTexture.repeat.set(40, 1); // Repeat 40 times horizontally for 500m length
            rightTexture.needsUpdate = true;
            materials.push(new THREE.MeshStandardMaterial({ map: rightTexture, side: THREE.BackSide }));

            // Left wall (long wall: 500 length x 4 height)
            const leftTexture = textTexture.clone();
            leftTexture.wrapS = THREE.RepeatWrapping;
            leftTexture.wrapT = THREE.RepeatWrapping;
            leftTexture.repeat.set(40, 1);
            leftTexture.needsUpdate = true;
            materials.push(new THREE.MeshStandardMaterial({ map: leftTexture, side: THREE.BackSide }));

            // Top (long: 500 length x 6 width)
            const topTexture = textTexture.clone();
            topTexture.wrapS = THREE.RepeatWrapping;
            topTexture.wrapT = THREE.RepeatWrapping;
            topTexture.repeat.set(40, 1);
            topTexture.needsUpdate = true;
            materials.push(new THREE.MeshStandardMaterial({ map: topTexture, side: THREE.BackSide }));

            // Bottom (long: 500 length x 6 width)
            const bottomTexture = textTexture.clone();
            bottomTexture.wrapS = THREE.RepeatWrapping;
            bottomTexture.wrapT = THREE.RepeatWrapping;
            bottomTexture.repeat.set(40, 1);
            bottomTexture.needsUpdate = true;
            materials.push(new THREE.MeshStandardMaterial({ map: bottomTexture, side: THREE.BackSide }));

            // Front wall (6 width x 4 height - normal)
            const frontTexture = textTexture.clone();
            frontTexture.wrapS = THREE.RepeatWrapping;
            frontTexture.wrapT = THREE.RepeatWrapping;
            frontTexture.repeat.set(1, 1);
            frontTexture.needsUpdate = true;
            materials.push(new THREE.MeshStandardMaterial({ map: frontTexture, side: THREE.BackSide }));

            // Back wall (6 width x 4 height - normal)
            const backTexture = textTexture.clone();
            backTexture.wrapS = THREE.RepeatWrapping;
            backTexture.wrapT = THREE.RepeatWrapping;
            backTexture.repeat.set(1, 1);
            backTexture.needsUpdate = true;
            materials.push(new THREE.MeshStandardMaterial({ map: backTexture, side: THREE.BackSide }));

            // Long corridor box (6 width, 4 height, 500 length)
            const corridorGeometry = new THREE.BoxGeometry(6, 4, 500);
            const corridor = new THREE.Mesh(corridorGeometry, materials);
            scene.add(corridor);

            // Ambient light (brighter for visibility)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            // Add directional light for better text visibility
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 10, 0);
            scene.add(directionalLight);

            // Monster system
            const monsters = [];

            function createMonster() {
                const monsterGroup = new THREE.Group();
                const monsterType = Math.random() > 0.6 ? 'green' : 'red';
                const baseColor = monsterType === 'red' ? '#ff0000' : '#00ff00';

                const fragmentCount = Math.floor(Math.random() * 21) + 40;

                for (let i = 0; i < fragmentCount; i++) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 256;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');

                    const alpha = 0.6 + Math.random() * 0.4;
                    ctx.fillStyle = baseColor;
                    ctx.font = `bold ${32 + Math.floor(Math.random() * 24)}px monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    ctx.shadowBlur = 15 + Math.random() * 10;
                    ctx.shadowColor = baseColor;
                    ctx.fillText('BUG', canvas.width / 2, canvas.height / 2);

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.magFilter = THREE.NearestFilter;
                    texture.minFilter = THREE.NearestFilter;

                    const spriteMaterial = new THREE.SpriteMaterial({
                        map: texture,
                        transparent: true,
                        opacity: monsterType === 'green' ? 0.2 : alpha
                    });

                    const sprite = new THREE.Sprite(spriteMaterial);

                    sprite.position.set(
                        (Math.random() - 0.5) * 1,
                        (Math.random() - 0.5) * 1,
                        (Math.random() - 0.5) * 1
                    );

                    const scale = 0.8 + Math.random() * 0.6;
                    sprite.scale.set(scale * 1.5, scale * 0.4, 1);

                    sprite.userData = {
                        floatOffset: Math.random() * Math.PI * 2,
                        floatSpeed: 0.5 + Math.random() * 0.5
                    };

                    monsterGroup.add(sprite);
                }

                monsterGroup.position.set(
                    (Math.random() - 0.5) * 4,
                    1.5 + Math.random() * 1,
                    -50 - Math.random() * 400
                );

                monsterGroup.userData = {
                    type: monsterType,
                    baseOpacity: monsterType === 'green' ? 0.2 : 0.8,
                    pulsePhase: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.3,
                    approachSpeed: 0.01 + Math.random() * 0.02,
                    frozen: false,
                    freezeTimer: 0,
                    revealed: false,
                    disintegrating: false
                };

                scene.add(monsterGroup);
                monsters.push(monsterGroup);
            }

            // Create initial monsters
            for (let i = 0; i < 3; i++) {
                createMonster();
            }

            setInterval(() => {
                if (monsters.length < 25) {
                    createMonster();
                }
            }, 1500);

            // Controls
            const state = {
                moveForward: false,
                moveBackward: false,
                moveLeft: false,
                moveRight: false,
                velocity: new THREE.Vector3(),
                direction: new THREE.Vector3(),
                isLocked: false
            };

            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': state.moveForward = true; break;
                    case 'KeyS': state.moveBackward = true; break;
                    case 'KeyA': state.moveLeft = true; break;
                    case 'KeyD': state.moveRight = true; break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': state.moveForward = false; break;
                    case 'KeyS': state.moveBackward = false; break;
                    case 'KeyA': state.moveLeft = false; break;
                    case 'KeyD': state.moveRight = false; break;
                }
            });

            renderer.domElement.addEventListener('click', () => {
                if (!state.isLocked) {
                    renderer.domElement.requestPointerLock();
                }
            }, { once: true });

            document.addEventListener('pointerlockchange', () => {
                state.isLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (!state.isLocked) return;

                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;

                camera.rotation.y -= movementX * 0.002;
                camera.rotation.x -= movementY * 0.002;

                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            });


            // Animation
            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);

                const delta = clock.getDelta();
                const time = Date.now() * 0.001;

                // Movement
                if (state.isLocked) {
                    const speed = 5.0;

                    state.velocity.x -= state.velocity.x * 10.0 * delta;
                    state.velocity.z -= state.velocity.z * 10.0 * delta;

                    state.direction.z = Number(state.moveForward) - Number(state.moveBackward);
                    state.direction.x = Number(state.moveRight) - Number(state.moveLeft);
                    state.direction.normalize();

                    if (state.moveForward || state.moveBackward) {
                        state.velocity.z -= state.direction.z * speed * delta;
                    }
                    if (state.moveLeft || state.moveRight) {
                        state.velocity.x += state.direction.x * speed * delta;
                    }

                    camera.position.x += state.velocity.x * Math.cos(camera.rotation.y) - state.velocity.z * Math.sin(camera.rotation.y);
                    camera.position.z += state.velocity.x * Math.sin(camera.rotation.y) + state.velocity.z * Math.cos(camera.rotation.y);

                    camera.position.x = Math.max(-2.5, Math.min(2.5, camera.position.x));
                    camera.position.z = Math.max(-252, Math.min(245, camera.position.z));
                }

                // Update monsters (simplified - no flashlight interaction)
                for (let i = monsters.length - 1; i >= 0; i--) {
                    const monsterGroup = monsters[i];
                    const userData = monsterGroup.userData;

                    // Move towards player
                    const directionToPlayer = new THREE.Vector3();
                    directionToPlayer.subVectors(camera.position, monsterGroup.position);
                    directionToPlayer.y = 0;
                    directionToPlayer.normalize();

                    monsterGroup.position.x += directionToPlayer.x * userData.approachSpeed;
                    monsterGroup.position.z += directionToPlayer.z * userData.approachSpeed;

                    // Rotate
                    monsterGroup.rotation.y += userData.rotationSpeed * delta;

                    // Pulse
                    const pulseFactor = Math.sin(time * 1.5 + userData.pulsePhase) * 0.2;

                    // Animate sprites
                    monsterGroup.children.forEach((sprite, index) => {
                        sprite.position.y += Math.sin(time * sprite.userData.floatSpeed + sprite.userData.floatOffset) * 0.005;
                        sprite.material.opacity = userData.baseOpacity + pulseFactor + Math.sin(time * 2 + index) * 0.1;
                    });
                }

                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
