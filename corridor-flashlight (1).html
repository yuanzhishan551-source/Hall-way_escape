<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Corridor Flashlight - 3D First Person</title>
    <!-- Version: 2.0 - Enhanced Monster Count & BUG Invasion System -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* UI Overlay */
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 16px;
            z-index: 100;
            text-shadow: 0 0 10px #00ff00;
            pointer-events: none;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #00ff00;
        }

        #mode-indicator {
            font-size: 20px;
            margin-bottom: 10px;
        }

        #instructions {
            font-size: 12px;
            opacity: 0.8;
            line-height: 1.5;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }

        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }


        /* BUG Invasion overlay - random scattered bugs */
        #bug-invasion {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 60;
            font-family: monospace;
            color: #ff0000;
            font-weight: bold;
            overflow: hidden;
        }

        .bug-text {
            position: absolute;
            text-shadow: 0 0 8px #ff0000, 0 0 12px #ff0000;
            opacity: 0.95;
            white-space: nowrap;
            animation: bugGlitch 0.3s infinite;
        }

        @keyframes bugGlitch {
            0%, 100% {
                text-shadow: 0 0 8px #ff0000, 0 0 12px #ff0000;
                opacity: 0.95;
            }
            50% {
                text-shadow: 2px 2px 8px #ff0000, -2px -2px 12px #ff0000;
                opacity: 0.85;
            }
        }

        /* Hit flash effect */
        #hit-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 70;
            transition: background 0.1s;
        }

        .flash-hit {
            background: rgba(255, 0, 0, 0.5) !important;
        }

        /* Game Over screen */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: #ff0000;
            font-size: 48px;
            text-shadow: 0 0 30px #ff0000;
        }

        #game-over.show {
            display: flex;
        }

        #game-over-text {
            animation: glitch 0.5s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(5px, -5px); }
            60% { transform: translate(-5px, -5px); }
            80% { transform: translate(5px, 5px); }
        }

        .restart-btn {
            margin-top: 30px;
            font-size: 20px;
            padding: 15px 30px;
            background: #ff0000;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
        }

        .restart-btn:hover {
            background: #ff3333;
        }

        /* Escape Success screen */
        #escape-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: #00ff00;
            font-size: 48px;
            text-shadow: 0 0 30px #00ff00;
        }

        #escape-screen.show {
            display: flex;
        }

        #escape-text {
            animation: fadeIn 2s ease-in;
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Hit Flash Effect -->
    <div id="hit-flash"></div>

    <!-- BUG Invasion Overlay -->
    <div id="bug-invasion"></div>

    <!-- Game Over Screen -->
    <div id="game-over">
        <div id="game-over-text">SYSTEM CORRUPTED</div>
        <div style="font-size: 24px; margin-top: 20px;">BUG OVERFLOW</div>
        <button class="restart-btn" onclick="location.reload()">RESTART</button>
    </div>

    <!-- Escape Success Screen -->
    <div id="escape-screen">
        <div id="escape-text">ESCAPED</div>
        <div style="font-size: 24px; margin-top: 20px;">You found the EXIT</div>
        <button class="restart-btn" style="background: #00ff00; color: #000;" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <!-- Crosshair -->
    <div id="crosshair"></div>

    <!-- UI Overlay -->
    <div id="ui-overlay">
        <div id="mode-indicator">MODE: WIDE BEAM</div>
        <div id="instructions">
            WASD: Move<br>
            MOUSE: Look Around<br>
            CLICK: Switch Mode<br>
            ESC: Unlock Mouse
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ===========================
        // GLOBAL STATE
        // ===========================
        const state = {
            currentMode: 0,
            isLocked: false,
            monsters: [],
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            audioContext: null,
            hitCount: 0,
            maxHits: 10,
            isGameOver: false,
            escaped: false,
            lastHitTime: 0,
            invulnerableTime: 1.0 // 1 second invulnerability after hit
        };

        // Mode configurations
        const modes = [
            {
                name: 'WIDE BEAM',
                color: 0xff0000,
                colorHex: '#ff0000',
                intensity: 2.5,
                distance: 25,
                angle: Math.PI / 4,
                penumbra: 0.5
            },
            {
                name: 'DETECTION',
                color: 0x00ff00,
                colorHex: '#00ff00',
                intensity: 1.8,
                distance: 30,
                angle: Math.PI / 6,
                penumbra: 0.4
            }
        ];

        // ===========================
        // SCENE SETUP
        // ===========================
        let scene, camera, renderer, spotlight, flashlightGroup;
        let corridor, monsters = [];
        let clock = new THREE.Clock();
        let wallTextures = []; // Store textures for animation

        // Intersection system
        let corridorSegments = [];
        let intersections = [];
        let correctPathCount = 0; // Track correct turns
        let currentDirection = new THREE.Vector3(0, 0, -1); // Player facing direction
        let playerRotation = 0; // Player Y rotation in radians

        // Checkpoint system
        let checkpoints = [
            { z: -100, passed: false, correctChoice: 'left', exitPanel: null, leftDoor: null, rightDoor: null, leftBlock: null, rightBlock: null }, // First checkpoint
            { z: -200, passed: false, correctChoice: 'right', exitPanel: null, leftDoor: null, rightDoor: null, leftBlock: null, rightBlock: null }, // Second checkpoint
            { z: -300, passed: false, correctChoice: 'left', exitPanel: null, leftDoor: null, rightDoor: null, leftBlock: null, rightBlock: null }  // Third checkpoint
        ];
        let currentCheckpoint = null;
        let atCheckpoint = false;
        let exitRevealed = false; // Track if exit is revealed by green light

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a0a, 1, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 0); // Eye level height

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false }); // No antialiasing for pixelated look
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio * 0.7); // Lower pixel ratio for pixelated effect
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap; // Pixelated shadows
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Ambient light (increased for visibility)
            const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
            scene.add(ambientLight);

            // Create flashlight group (moves with camera)
            flashlightGroup = new THREE.Group();
            camera.add(flashlightGroup);
            scene.add(camera);

            // Spotlight (flashlight)
            spotlight = new THREE.SpotLight(
                modes[0].color,
                modes[0].intensity,
                modes[0].distance,
                modes[0].angle,
                modes[0].penumbra
            );
            spotlight.position.set(0, -0.2, -0.5);
            spotlight.target.position.set(0, -0.2, -5);
            spotlight.castShadow = true;
            spotlight.shadow.mapSize.width = 512; // Lower resolution for pixelated shadows
            spotlight.shadow.mapSize.height = 512;

            flashlightGroup.add(spotlight);
            flashlightGroup.add(spotlight.target);

            // Initialize audio
            initAudio();

            // Create corridor
            createCorridor();

            // Create initial monsters
            createMonster();
            createMonster();
            createMonster();
            setInterval(() => {
                if (monsters.length < 25) { // Increased from 10 to 25
                    createMonster();
                }
            }, 1500); // Faster spawn: 4000ms -> 1500ms

            // Setup controls
            setupControls();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Start animation loop
            animate();
        }

        // ===========================
        // CREATE TEXT TEXTURE - CONTINUOUS LONG TEXT
        // ===========================
        function createTextTexture(text, width = 4096, height = 4096) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 96px Courier New'; // Increased font size

            // Create very long continuous text by repeating characters (no spaces)
            const chars = text.replace(/ /g, ''); // Remove all spaces from source
            let longText = '';
            for (let i = 0; i < 3000; i++) { // More characters to fill canvas completely
                longText += chars.charAt(Math.floor(Math.random() * chars.length));
            }

            let y = 96; // Start from top (font size)
            let x = 0; // No left margin
            const lineHeight = 130; // Wider line spacing for better readability

            // Fill the entire canvas with continuous text character by character (zero spacing)
            for (let i = 0; i < longText.length; i++) {
                const char = longText.charAt(i);
                const metrics = ctx.measureText(char);

                if (x + metrics.width > width) { // Fill to right edge
                    x = 0;
                    y += lineHeight;
                    if (y > height) break; // Fill to bottom edge
                }

                ctx.fillText(char, x, y);
                x += metrics.width; // Exact character width, no extra spacing
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // ===========================
        // CREATE 3D CORRIDOR
        // ===========================
        function createCorridor() {
            // Sample text with warnings
            const wallText = `RUN ESCAPE DANGER GET OUT FLEE WARNING EXIT HURRY # | / \\ - + = * : . X H M W N data information technology digital world artificial intelligence machine learning algorithm code programming software development BUG ERROR SYSTEM CORRUPTED`;

            // Create text texture
            const textTexture = createTextTexture(wallText);

            // Create separate materials for each face with continuous text
            const materials = [];

            // Right wall (long wall: 500 length x 10 height)
            const rightTexture = textTexture.clone();
            rightTexture.wrapS = THREE.RepeatWrapping;
            rightTexture.wrapT = THREE.RepeatWrapping;
            rightTexture.repeat.set(50, 2); // Reduce to half for larger text blocks
            rightTexture.needsUpdate = true;
            wallTextures.push(rightTexture); // Store for animation
            materials.push(new THREE.MeshStandardMaterial({
                map: rightTexture,
                side: THREE.BackSide,
                emissive: 0x555555,
                emissiveMap: rightTexture,
                emissiveIntensity: 0.8
            }));

            // Left wall (long wall: 500 length x 10 height)
            const leftTexture = textTexture.clone();
            leftTexture.wrapS = THREE.RepeatWrapping;
            leftTexture.wrapT = THREE.RepeatWrapping;
            leftTexture.repeat.set(50, 2); // Reduce to half for larger text blocks
            leftTexture.needsUpdate = true;
            wallTextures.push(leftTexture); // Store for animation
            materials.push(new THREE.MeshStandardMaterial({
                map: leftTexture,
                side: THREE.BackSide,
                emissive: 0x555555,
                emissiveMap: leftTexture,
                emissiveIntensity: 0.8
            }));

            // Top (ceiling: 500 length x 6 width) - Add emissive for visibility
            const topTexture = textTexture.clone();
            topTexture.wrapS = THREE.RepeatWrapping;
            topTexture.wrapT = THREE.RepeatWrapping;
            topTexture.repeat.set(1, 100); // Reduce to half for larger text blocks
            topTexture.needsUpdate = true;
            wallTextures.push(topTexture); // Store for animation
            materials.push(new THREE.MeshStandardMaterial({
                map: topTexture,
                side: THREE.BackSide,
                emissive: 0x555555,
                emissiveMap: topTexture,
                emissiveIntensity: 0.8
            }));

            // Bottom (floor: 500 length x 6 width) - Add stronger emissive for visibility
            const bottomTexture = textTexture.clone();
            bottomTexture.wrapS = THREE.RepeatWrapping;
            bottomTexture.wrapT = THREE.RepeatWrapping;
            bottomTexture.repeat.set(1, 100); // Reduce to half for larger text blocks
            bottomTexture.needsUpdate = true;
            wallTextures.push(bottomTexture); // Store for animation
            materials.push(new THREE.MeshStandardMaterial({
                map: bottomTexture,
                side: THREE.BackSide,
                emissive: 0x555555,
                emissiveMap: bottomTexture,
                emissiveIntensity: 0.8
            }));

            // Front wall (6 width x 10 height - normal)
            const frontTexture = textTexture.clone();
            frontTexture.wrapS = THREE.RepeatWrapping;
            frontTexture.wrapT = THREE.RepeatWrapping;
            frontTexture.repeat.set(1, 1);
            frontTexture.needsUpdate = true;
            materials.push(new THREE.MeshStandardMaterial({ map: frontTexture, side: THREE.BackSide }));

            // Back wall (6 width x 10 height - normal)
            const backTexture = textTexture.clone();
            backTexture.wrapS = THREE.RepeatWrapping;
            backTexture.wrapT = THREE.RepeatWrapping;
            backTexture.repeat.set(1, 1);
            backTexture.needsUpdate = true;
            materials.push(new THREE.MeshStandardMaterial({ map: backTexture, side: THREE.BackSide }));

            // Long corridor box (6 width, 10 height, 500 length) - Increased height
            const corridorGeometry = new THREE.BoxGeometry(6, 10, 500);
            corridor = new THREE.Mesh(corridorGeometry, materials);
            scene.add(corridor);

            // Exit door will be created after 3 correct choices
            // createExitDoor(500, 6, 10);

            // Create visual checkpoint markers
            createCheckpointMarkers();
        }

        // ===========================
        // CREATE CHECKPOINT MARKERS
        // ===========================
        function createCheckpointMarkers() {
            checkpoints.forEach((checkpoint, index) => {
                // Create floor marker with arrows indicating direction
                const markerCanvas = document.createElement('canvas');
                markerCanvas.width = 512;
                markerCanvas.height = 512;
                const ctx = markerCanvas.getContext('2d');

                // Yellow glowing circle
                ctx.fillStyle = '#ffaa00';
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffaa00';
                ctx.beginPath();
                ctx.arc(256, 256, 180, 0, Math.PI * 2);
                ctx.fill();

                // White inner circle
                ctx.fillStyle = '#ffffff';
                ctx.shadowBlur = 0;
                ctx.beginPath();
                ctx.arc(256, 256, 150, 0, Math.PI * 2);
                ctx.fill();

                // Black text with checkpoint number
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 120px monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${index + 1}`, 256, 220);

                // Arrows indicating left/right choice
                ctx.font = 'bold 60px monospace';
                ctx.fillText('Qâ†  â†’E', 256, 320);

                const markerTexture = new THREE.CanvasTexture(markerCanvas);
                markerTexture.magFilter = THREE.NearestFilter;
                markerTexture.minFilter = THREE.NearestFilter;

                const markerGeometry = new THREE.PlaneGeometry(3, 3);
                const markerMaterial = new THREE.MeshStandardMaterial({
                    map: markerTexture,
                    transparent: true,
                    emissive: 0xffaa00,
                    emissiveIntensity: 0.5
                });

                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.rotation.x = -Math.PI / 2; // Lay flat on floor
                marker.position.set(0, 0.01, checkpoint.z); // Slightly above floor to prevent z-fighting
                scene.add(marker);

                // Add pulsing light at checkpoint
                const checkpointLight = new THREE.PointLight(0xffaa00, 0.8, 10);
                checkpointLight.position.set(0, 2, checkpoint.z);
                scene.add(checkpointLight);

                // Store light reference for animation
                checkpoint.light = checkpointLight;

                // Create EXIT text panel on correct wall (initially invisible)
                const exitCanvas = document.createElement('canvas');
                exitCanvas.width = 1024;
                exitCanvas.height = 512;
                const exitCtx = exitCanvas.getContext('2d');

                // Green glowing background
                exitCtx.fillStyle = '#00ff00';
                exitCtx.shadowBlur = 30;
                exitCtx.shadowColor = '#00ff00';
                exitCtx.fillRect(0, 0, exitCanvas.width, exitCanvas.height);

                // Black EXIT text
                exitCtx.shadowBlur = 0;
                exitCtx.fillStyle = '#000000';
                exitCtx.font = 'bold 200px monospace';
                exitCtx.textAlign = 'center';
                exitCtx.textBaseline = 'middle';
                exitCtx.fillText('EXIT', exitCanvas.width / 2, exitCanvas.height / 2);

                // Arrow pointing forward
                exitCtx.font = 'bold 100px monospace';
                exitCtx.fillText('â†“', exitCanvas.width / 2, exitCanvas.height / 2 + 150);

                const exitTexture = new THREE.CanvasTexture(exitCanvas);
                exitTexture.magFilter = THREE.NearestFilter;
                exitTexture.minFilter = THREE.NearestFilter;

                const exitGeometry = new THREE.PlaneGeometry(4, 2);
                const exitMaterial = new THREE.MeshStandardMaterial({
                    map: exitTexture,
                    transparent: true,
                    opacity: 0, // Start invisible
                    emissive: 0x00ff00,
                    emissiveIntensity: 1.0,
                    side: THREE.DoubleSide
                });

                const exitPanel = new THREE.Mesh(exitGeometry, exitMaterial);

                // Position on correct wall
                if (checkpoint.correctChoice === 'left') {
                    exitPanel.position.set(-2.9, 3, checkpoint.z); // Left wall
                    exitPanel.rotation.y = Math.PI / 2;
                } else {
                    exitPanel.position.set(2.9, 3, checkpoint.z); // Right wall
                    exitPanel.rotation.y = -Math.PI / 2;
                }

                scene.add(exitPanel);
                checkpoint.exitPanel = exitPanel;

                // Create LEFT door opening with frame
                const leftDoorGroup = new THREE.Group();

                // Door frame (white border)
                const doorFrameGeometry = new THREE.BoxGeometry(0.2, 8, 3);
                const doorFrameMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    emissive: 0x333333,
                    emissiveIntensity: 0.3
                });

                // Left frame post
                const leftFramePost = new THREE.Mesh(doorFrameGeometry, doorFrameMaterial);
                leftFramePost.position.set(-2.95, 4, checkpoint.z);
                leftDoorGroup.add(leftFramePost);

                // Top frame
                const topFrameGeometry = new THREE.BoxGeometry(3, 8, 0.2);
                const leftTopFrame = new THREE.Mesh(topFrameGeometry, doorFrameMaterial);
                leftTopFrame.position.set(-4.45, 4, checkpoint.z);
                leftTopFrame.rotation.y = Math.PI / 2;
                leftDoorGroup.add(leftTopFrame);

                // Dark passage interior (black plane to simulate depth)
                const passageGeometry = new THREE.PlaneGeometry(3, 8);
                const passageMaterial = new THREE.MeshStandardMaterial({
                    color: 0x000000,
                    emissive: 0x001100,
                    emissiveIntensity: 0.1
                });
                const leftPassage = new THREE.Mesh(passageGeometry, passageMaterial);
                leftPassage.position.set(-2.95, 4, checkpoint.z);
                leftPassage.rotation.y = Math.PI / 2;
                leftDoorGroup.add(leftPassage);

                scene.add(leftDoorGroup);
                checkpoint.leftDoor = leftDoorGroup;

                // Create RIGHT door opening with frame
                const rightDoorGroup = new THREE.Group();

                // Right frame post
                const rightFramePost = new THREE.Mesh(doorFrameGeometry, doorFrameMaterial);
                rightFramePost.position.set(2.95, 4, checkpoint.z);
                rightDoorGroup.add(rightFramePost);

                // Top frame
                const rightTopFrame = new THREE.Mesh(topFrameGeometry, doorFrameMaterial);
                rightTopFrame.position.set(4.45, 4, checkpoint.z);
                rightTopFrame.rotation.y = Math.PI / 2;
                rightDoorGroup.add(rightTopFrame);

                // Dark passage interior
                const rightPassage = new THREE.Mesh(passageGeometry, passageMaterial);
                rightPassage.position.set(2.95, 4, checkpoint.z);
                rightPassage.rotation.y = -Math.PI / 2;
                rightDoorGroup.add(rightPassage);

                scene.add(rightDoorGroup);
                checkpoint.rightDoor = rightDoorGroup;

                // Create blocking walls (initially invisible, will appear for wrong choices)
                const blockWallGeometry = new THREE.PlaneGeometry(3, 8);
                const blockWallMaterial = new THREE.MeshStandardMaterial({
                    color: 0x330000,
                    transparent: true,
                    opacity: 0,
                    emissive: 0xff0000,
                    emissiveIntensity: 0
                });

                // Left blocking wall
                const leftBlock = new THREE.Mesh(blockWallGeometry, blockWallMaterial.clone());
                leftBlock.position.set(-2.95, 4, checkpoint.z);
                leftBlock.rotation.y = Math.PI / 2;
                scene.add(leftBlock);
                checkpoint.leftBlock = leftBlock;

                // Right blocking wall
                const rightBlock = new THREE.Mesh(blockWallGeometry, blockWallMaterial.clone());
                rightBlock.position.set(2.95, 4, checkpoint.z);
                rightBlock.rotation.y = -Math.PI / 2;
                scene.add(rightBlock);
                checkpoint.rightBlock = rightBlock;
            });
        }

        // ===========================
        // CREATE EXIT DOOR
        // ===========================
        function createExitDoor(length, width, height) {
            const doorGroup = new THREE.Group();

            // Door position at the end of corridor
            const doorZ = -length / 2 + 0.5; // Slight offset from wall

            // Door frame (black)
            const doorGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.8,
                metalness: 0.2
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.5, doorZ);
            door.receiveShadow = true;
            door.castShadow = true;
            doorGroup.add(door);

            // Door handle (darker gray)
            const handleGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.1);
            const handleMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.5
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.7, 1.5, doorZ + 0.15);
            doorGroup.add(handle);

            // EXIT sign (green glowing)
            const signCanvas = document.createElement('canvas');
            signCanvas.width = 256;
            signCanvas.height = 128;
            const ctx = signCanvas.getContext('2d');

            // Green background
            ctx.fillStyle = '#00aa00';
            ctx.fillRect(0, 0, signCanvas.width, signCanvas.height);

            // White border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.strokeRect(5, 5, signCanvas.width - 10, signCanvas.height - 10);

            // EXIT text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 72px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('EXIT', signCanvas.width / 2, signCanvas.height / 2);

            // Running man icon (simple representation)
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(60, 64, 12, 0, Math.PI * 2); // Head
            ctx.fill();
            ctx.fillRect(55, 76, 10, 20); // Body
            ctx.fillRect(50, 80, 5, 15); // Left leg
            ctx.fillRect(65, 80, 5, 15); // Right leg

            const signTexture = new THREE.CanvasTexture(signCanvas);
            signTexture.magFilter = THREE.NearestFilter;
            signTexture.minFilter = THREE.NearestFilter;

            const signGeometry = new THREE.PlaneGeometry(1.5, 0.75);
            const signMaterial = new THREE.MeshStandardMaterial({
                map: signTexture,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 3.3, doorZ + 0.1);
            doorGroup.add(sign);

            // Green light from sign
            const signLight = new THREE.PointLight(0x00ff00, 0.5, 5);
            signLight.position.set(0, 3.3, doorZ + 0.5);
            doorGroup.add(signLight);

            scene.add(doorGroup);
        }

        // ===========================
        // CREATE TEXT MONSTERS (CLUSTERS)
        // ===========================
        function createMonster() {
            const monsterTexts = ['BUG']; // Only use BUG

            // Create a group for the monster cluster
            const monsterCluster = new THREE.Group();

            // Determine monster type
            const monsterType = Math.random() > 0.6 ? 'green' : 'red';
            const baseColor = monsterType === 'red' ? '#ff0000' : '#00ff00';

            // Create 40-60 text fragments in a cluster (much denser)
            const fragmentCount = Math.floor(Math.random() * 21) + 40; // 40-60 fragments

            for (let i = 0; i < fragmentCount; i++) {
                const text = monsterTexts[Math.floor(Math.random() * monsterTexts.length)];

                // Create text sprite
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // Vary opacity and size for depth
                const alpha = 0.6 + Math.random() * 0.4;
                ctx.fillStyle = baseColor;
                ctx.font = `bold ${32 + Math.floor(Math.random() * 24)}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Add glow
                ctx.shadowBlur = 15 + Math.random() * 10;
                ctx.shadowColor = baseColor;
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;

                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: monsterType === 'green' ? 0.2 : alpha // Green monsters nearly invisible
                });

                const sprite = new THREE.Sprite(spriteMaterial);

                // Random position within cluster (1x1x1 cube - much tighter)
                sprite.position.set(
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1
                );

                // Random scale
                const scale = 0.8 + Math.random() * 0.6;
                sprite.scale.set(scale * 1.5, scale * 0.4, 1);

                // Store individual fragment animation data
                sprite.userData = {
                    floatOffset: Math.random() * Math.PI * 2,
                    floatSpeed: 0.5 + Math.random() * 0.5
                };

                monsterCluster.add(sprite);
            }

            // Position cluster in corridor (far away from player in 500m corridor)
            monsterCluster.position.set(
                (Math.random() - 0.5) * 4,
                1.5 + Math.random() * 1,
                -50 - Math.random() * 400 // Start far away in long corridor
            );

            // Store cluster data
            monsterCluster.userData = {
                type: monsterType,
                baseOpacity: monsterType === 'green' ? 0.2 : 0.8,
                pulsePhase: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.3,
                approachSpeed: 0.01 + Math.random() * 0.02, // Speed towards player
                frozen: false,
                freezeTimer: 0,
                revealed: false,
                disintegrating: false
            };

            scene.add(monsterCluster);
            monsters.push(monsterCluster);
        }

        // ===========================
        // CONTROLS
        // ===========================
        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': state.moveForward = true; break;
                    case 'KeyS': state.moveBackward = true; break;
                    case 'KeyA': state.moveLeft = true; break;
                    case 'KeyD': state.moveRight = true; break;
                    case 'KeyQ':
                        if (atCheckpoint && currentCheckpoint) {
                            handleCheckpointChoice('left');
                        }
                        break;
                    case 'KeyE':
                        if (atCheckpoint && currentCheckpoint) {
                            handleCheckpointChoice('right');
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': state.moveForward = false; break;
                    case 'KeyS': state.moveBackward = false; break;
                    case 'KeyA': state.moveLeft = false; break;
                    case 'KeyD': state.moveRight = false; break;
                }
            });

            // Mouse look - request pointer lock on first click
            renderer.domElement.addEventListener('click', () => {
                if (!state.isLocked) {
                    renderer.domElement.requestPointerLock();
                }
            }, { once: true });

            document.addEventListener('pointerlockchange', () => {
                state.isLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (!state.isLocked) return;

                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;

                camera.rotation.y -= movementX * 0.002;
                camera.rotation.x -= movementY * 0.002;

                // Clamp vertical rotation
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            });

            // Click to switch mode
            document.addEventListener('click', () => {
                if (state.isLocked) {
                    switchMode();
                }
            });
        }

        // ===========================
        // SWITCH FLASHLIGHT MODE
        // ===========================
        function switchMode() {
            state.currentMode = (state.currentMode + 1) % modes.length;
            const mode = modes[state.currentMode];

            spotlight.color.setHex(mode.color);
            spotlight.intensity = mode.intensity;
            spotlight.distance = mode.distance;
            spotlight.angle = mode.angle;
            spotlight.penumbra = mode.penumbra;

            document.getElementById('mode-indicator').textContent = `MODE: ${mode.name}`;
            document.getElementById('mode-indicator').style.color = mode.colorHex;

            // Flicker effect
            spotlight.intensity *= 1.5;
            setTimeout(() => {
                spotlight.intensity = mode.intensity;
            }, 100);
        }

        // ===========================
        // CHECKPOINT SYSTEM
        // ===========================
        function handleCheckpointChoice(choice) {
            if (!currentCheckpoint || currentCheckpoint.passed) return;

            currentCheckpoint.passed = true;
            atCheckpoint = false;

            if (choice === currentCheckpoint.correctChoice) {
                correctPathCount++;
                console.log(`âœ… Correct choice! Progress: ${correctPathCount}/3`);

                // Update UI
                document.getElementById('mode-indicator').textContent = `CORRECT PATHS: ${correctPathCount}/3`;
                document.getElementById('mode-indicator').style.color = '#00ff00';

                setTimeout(() => {
                    document.getElementById('mode-indicator').textContent = `MODE: ${modes[state.currentMode].name}`;
                    document.getElementById('mode-indicator').style.color = modes[state.currentMode].colorHex;
                }, 2000);

                // Block the wrong path - close the door with red wall
                if (choice === 'left') {
                    // Block right door
                    if (currentCheckpoint.rightBlock) {
                        currentCheckpoint.rightBlock.material.opacity = 0.9;
                        currentCheckpoint.rightBlock.material.emissiveIntensity = 0.5;
                    }
                } else {
                    // Block left door
                    if (currentCheckpoint.leftBlock) {
                        currentCheckpoint.leftBlock.material.opacity = 0.9;
                        currentCheckpoint.leftBlock.material.emissiveIntensity = 0.5;
                    }
                }

                // Check if all 3 correct - create exit door
                if (correctPathCount >= 3) {
                    createExitDoor(500, 6, 10);
                    console.log('ðŸšª Exit door appeared!');
                }
            } else {
                console.log(`âŒ Wrong choice. Progress: ${correctPathCount}/3`);

                // Flash red
                document.getElementById('mode-indicator').textContent = `WRONG PATH`;
                document.getElementById('mode-indicator').style.color = '#ff0000';

                setTimeout(() => {
                    document.getElementById('mode-indicator').textContent = `MODE: ${modes[state.currentMode].name}`;
                    document.getElementById('mode-indicator').style.color = modes[state.currentMode].colorHex;
                }, 2000);

                // Block the chosen wrong path
                if (choice === 'left') {
                    if (currentCheckpoint.leftBlock) {
                        currentCheckpoint.leftBlock.material.opacity = 0.9;
                        currentCheckpoint.leftBlock.material.emissiveIntensity = 0.5;
                    }
                } else {
                    if (currentCheckpoint.rightBlock) {
                        currentCheckpoint.rightBlock.material.opacity = 0.9;
                        currentCheckpoint.rightBlock.material.emissiveIntensity = 0.5;
                    }
                }
            }

            currentCheckpoint = null;
        }

        function checkCheckpoints() {
            // Check if player is near any checkpoint
            for (let cp of checkpoints) {
                if (!cp.passed && Math.abs(camera.position.z - cp.z) < 10) {
                    if (!atCheckpoint) {
                        atCheckpoint = true;
                        currentCheckpoint = cp;
                        console.log('ðŸ“ Checkpoint reached! Press Q (left) or E (right)');

                        // Update UI
                        document.getElementById('instructions').innerHTML = `
                            CHECKPOINT!<br>
                            Q: Choose LEFT<br>
                            E: Choose RIGHT<br>
                            Progress: ${correctPathCount}/3<br>
                            <span style="color: #00ff00;">Use GREEN light to reveal EXIT</span>
                        `;
                    }
                    return;
                }
            }

            // Player left checkpoint area
            if (atCheckpoint && currentCheckpoint && Math.abs(camera.position.z - currentCheckpoint.z) > 15) {
                atCheckpoint = false;
                currentCheckpoint = null;

                // Reset UI
                document.getElementById('instructions').innerHTML = `
                    WASD: Move<br>
                    MOUSE: Look Around<br>
                    CLICK: Switch Mode<br>
                    ESC: Unlock Mouse
                `;
            }
        }

        // ===========================
        // UPDATE CHECKPOINT EFFECTS
        // ===========================
        function updateCheckpointEffects(delta) {
            const time = Date.now() * 0.001;

            checkpoints.forEach(checkpoint => {
                // Pulse checkpoint light
                if (checkpoint.light && !checkpoint.passed) {
                    const pulse = Math.sin(time * 2) * 0.3 + 0.8;
                    checkpoint.light.intensity = pulse;
                }

                // Check if green light is revealing EXIT panel
                if (checkpoint.exitPanel && !checkpoint.passed &&
                    state.currentMode === 1 && atCheckpoint && currentCheckpoint === checkpoint) {

                    // Check if player is looking at the correct wall
                    const distanceToPanel = checkpoint.exitPanel.position.distanceTo(camera.position);

                    if (distanceToPanel < 15) { // Within reasonable viewing distance
                        // Get direction camera is looking
                        const cameraDirection = new THREE.Vector3(0, 0, -1);
                        cameraDirection.applyQuaternion(camera.quaternion);

                        // Get direction to EXIT panel
                        const toPanelDirection = new THREE.Vector3();
                        toPanelDirection.subVectors(checkpoint.exitPanel.position, camera.position);
                        toPanelDirection.normalize();

                        // Calculate angle
                        const angle = Math.acos(cameraDirection.dot(toPanelDirection));

                        // If looking at panel (within 45 degrees), reveal it
                        if (angle < Math.PI / 4) {
                            // Fade in EXIT panel
                            checkpoint.exitPanel.material.opacity = Math.min(
                                checkpoint.exitPanel.material.opacity + delta * 2,
                                1.0
                            );
                        } else {
                            // Fade out when not looking
                            checkpoint.exitPanel.material.opacity = Math.max(
                                checkpoint.exitPanel.material.opacity - delta * 3,
                                0
                            );
                        }
                    } else {
                        // Fade out when too far
                        checkpoint.exitPanel.material.opacity = Math.max(
                            checkpoint.exitPanel.material.opacity - delta * 3,
                            0
                        );
                    }
                } else if (checkpoint.exitPanel && checkpoint.exitPanel.material.opacity > 0) {
                    // Fade out if not at checkpoint or not using green light
                    checkpoint.exitPanel.material.opacity = Math.max(
                        checkpoint.exitPanel.material.opacity - delta * 3,
                        0
                    );
                }
            });
        }

        // ===========================
        // UPDATE MOVEMENT
        // ===========================
        function updateMovement(delta) {
            if (!state.isLocked || state.isGameOver) return;

            const speed = 5.0;

            state.velocity.x -= state.velocity.x * 10.0 * delta;
            state.velocity.z -= state.velocity.z * 10.0 * delta;

            state.direction.z = Number(state.moveForward) - Number(state.moveBackward);
            state.direction.x = Number(state.moveRight) - Number(state.moveLeft);
            state.direction.normalize();

            if (state.moveForward || state.moveBackward) {
                state.velocity.z -= state.direction.z * speed * delta;
            }
            if (state.moveLeft || state.moveRight) {
                state.velocity.x += state.direction.x * speed * delta; // Fixed: changed -= to +=
            }

            // Apply velocity
            camera.position.x += state.velocity.x * Math.cos(camera.rotation.y) - state.velocity.z * Math.sin(camera.rotation.y);
            camera.position.z += state.velocity.x * Math.sin(camera.rotation.y) + state.velocity.z * Math.cos(camera.rotation.y);

            // Keep player in corridor bounds (500m corridor)
            camera.position.x = Math.max(-2.5, Math.min(2.5, camera.position.x));
            camera.position.z = Math.max(-252, Math.min(245, camera.position.z));

            // Check if player reached exit door (escaped)
            if (camera.position.z < -249) {
                state.escaped = true;
                showEscapeScreen();
            }
        }

        // ===========================
        // UPDATE MONSTERS (CLUSTERS)
        // ===========================
        function updateMonsters(delta) {
            const time = Date.now() * 0.001;
            const currentMode = modes[state.currentMode];

            for (let i = monsters.length - 1; i >= 0; i--) {
                const monsterCluster = monsters[i];
                const userData = monsterCluster.userData;

                // Check if monster is hit by flashlight
                const isHitByFlashlight = checkFlashlightHit(monsterCluster);

                // Handle freeze timer
                if (userData.frozen && userData.freezeTimer > 0) {
                    userData.freezeTimer -= delta;
                    if (userData.freezeTimer <= 0) {
                        userData.frozen = false;
                    }
                }

                // Apply flashlight effects based on mode
                if (isHitByFlashlight) {
                    // Mode 0: Wide Beam (Orange) - Freezes all monsters
                    if (state.currentMode === 0) {
                        if (!userData.frozen) {
                            userData.frozen = true;
                            userData.freezeTimer = 2.0; // Freeze for 2 seconds
                            playStaticClick();
                        }
                    }

                    // Mode 1: Detection (Green) - Disintegrates green monsters
                    else if (state.currentMode === 1 && userData.type === 'green') {
                        if (!userData.disintegrating) {
                            userData.disintegrating = true;
                            userData.disintegrateTime = time;
                            playDetectionNoise();
                        }
                    }
                }

                // Handle disintegration
                if (userData.disintegrating) {
                    const disintegrateProgress = (time - userData.disintegrateTime) / 2.0; // 2 seconds to disintegrate
                    if (disintegrateProgress >= 1.0) {
                        // Remove completely disintegrated monster
                        scene.remove(monsterCluster);
                        monsters.splice(i, 1);
                        continue;
                    }

                    // Fade out and break apart
                    monsterCluster.children.forEach((sprite, index) => {
                        sprite.material.opacity *= (1 - disintegrateProgress);
                        sprite.position.y += disintegrateProgress * 0.1;
                    });
                }

                // Move cluster slowly towards player (only if not frozen)
                if (!userData.frozen && !userData.disintegrating) {
                    const directionToPlayer = new THREE.Vector3();
                    directionToPlayer.subVectors(camera.position, monsterCluster.position);
                    directionToPlayer.y = 0; // Only move horizontally
                    directionToPlayer.normalize();

                    monsterCluster.position.x += directionToPlayer.x * userData.approachSpeed;
                    monsterCluster.position.z += directionToPlayer.z * userData.approachSpeed;
                }

                // Slow rotation of entire cluster (slower when frozen)
                const rotationSpeed = userData.frozen ? userData.rotationSpeed * 0.1 : userData.rotationSpeed;
                monsterCluster.rotation.y += rotationSpeed * delta;

                // Pulse opacity of entire cluster
                const pulseFactor = Math.sin(time * 1.5 + userData.pulsePhase) * 0.2;

                // Animate individual text fragments within cluster
                monsterCluster.children.forEach((sprite, index) => {
                    if (userData.disintegrating) return; // Skip normal animation if disintegrating

                    // Individual floating motion
                    sprite.position.y += Math.sin(time * sprite.userData.floatSpeed + sprite.userData.floatOffset) * 0.005;

                    // Adjust opacity based on state
                    let targetOpacity;
                    if (userData.type === 'green') {
                        // Green monsters: nearly invisible unless revealed
                        targetOpacity = userData.revealed ? 0.8 : 0.1;
                    } else {
                        // Red monsters: visible, more visible when revealed
                        targetOpacity = userData.revealed ? 1.0 : (userData.baseOpacity + pulseFactor);
                    }

                    // Apply freeze effect (red tint)
                    if (userData.frozen) {
                        sprite.material.color.setHex(0xff0000); // Red tint when frozen
                    } else {
                        sprite.material.color.setHex(0xffffff); // Normal color
                    }

                    sprite.material.opacity = targetOpacity + Math.sin(time * 2 + index) * 0.1;

                    // Slight rotation for each fragment
                    sprite.rotation.z = Math.sin(time * 0.5 + index) * 0.1;
                });

                // Check if monster hits player
                const distanceToPlayer = monsterCluster.position.distanceTo(camera.position);
                if (distanceToPlayer < 2) {
                    // Monster hit the player!
                    const currentTime = Date.now() * 0.001;
                    if (currentTime - state.lastHitTime > state.invulnerableTime) {
                        playerHit();
                        state.lastHitTime = currentTime;
                    }
                    // Remove monster after hit
                    scene.remove(monsterCluster);
                    monsters.splice(i, 1);
                    continue;
                }

                // Remove if too far
                if (distanceToPlayer > 500) {
                    scene.remove(monsterCluster);
                    monsters.splice(i, 1);
                }
            }
        }

        // ===========================
        // CHECK FLASHLIGHT HIT
        // ===========================
        function checkFlashlightHit(monsterCluster) {
            // Get monster position relative to camera
            const monsterPos = new THREE.Vector3();
            monsterPos.copy(monsterCluster.position);

            // Transform to camera space
            const cameraToMonster = new THREE.Vector3();
            cameraToMonster.subVectors(monsterPos, camera.position);

            // Get distance
            const distance = cameraToMonster.length();

            // Get current mode settings
            const mode = modes[state.currentMode];

            // Check if within flashlight distance
            if (distance > mode.distance) return false;

            // Get direction camera is looking
            const cameraDirection = new THREE.Vector3(0, 0, -1);
            cameraDirection.applyQuaternion(camera.quaternion);

            // Calculate angle between camera direction and monster direction
            cameraToMonster.normalize();
            const angle = Math.acos(cameraDirection.dot(cameraToMonster));

            // Check if within spotlight cone angle
            return angle < mode.angle;
        }

        // ===========================
        // AUDIO FEEDBACK
        // ===========================
        function playStaticClick() {
            // Simple click sound feedback
            if (state.audioContext) {
                const oscillator = state.audioContext.createOscillator();
                const gainNode = state.audioContext.createGain();
                oscillator.frequency.value = 800;
                oscillator.type = 'square';
                gainNode.gain.setValueAtTime(0.1, state.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.1);
                oscillator.connect(gainNode);
                gainNode.connect(state.audioContext.destination);
                oscillator.start();
                oscillator.stop(state.audioContext.currentTime + 0.1);
            }
        }

        function playDetectionNoise() {
            // Detection sound feedback
            if (state.audioContext) {
                const oscillator = state.audioContext.createOscillator();
                const gainNode = state.audioContext.createGain();
                oscillator.frequency.value = 1200;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.15, state.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.2);
                oscillator.connect(gainNode);
                gainNode.connect(state.audioContext.destination);
                oscillator.start();
                oscillator.stop(state.audioContext.currentTime + 0.2);
            }
        }

        // Initialize audio context
        function initAudio() {
            try {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn('Web Audio API not supported');
            }
        }

        // ===========================
        // PLAYER HIT & DAMAGE SYSTEM
        // ===========================
        function playerHit() {
            if (state.isGameOver) return;

            state.hitCount++;
            console.log(`Hit! Count: ${state.hitCount}/${state.maxHits}`);

            // Trigger hit effect
            triggerHitEffect();

            // Update BUG invasion UI
            updateBugInvasion();

            // Play hit sound
            playHitSound();

            // Check for game over
            if (state.hitCount >= state.maxHits) {
                triggerGameOver();
            }
        }

        // Trigger visual hit effect
        function triggerHitEffect() {
            const hitFlash = document.getElementById('hit-flash');

            // Flash red
            hitFlash.classList.add('flash-hit');
            setTimeout(() => {
                hitFlash.classList.remove('flash-hit');
            }, 200);

            // Camera shake effect
            const originalY = camera.rotation.y;
            const originalX = camera.rotation.x;
            const shakeAmount = 0.1;

            // Quick shake
            camera.rotation.x += (Math.random() - 0.5) * shakeAmount;
            camera.rotation.y += (Math.random() - 0.5) * shakeAmount;

            setTimeout(() => {
                camera.rotation.x = originalX;
                camera.rotation.y = originalY;
            }, 100);
        }

        // Update BUG text invasion - random scattered all over edges
        function updateBugInvasion() {
            const container = document.getElementById('bug-invasion');

            // Calculate how many BUGs to add (exponential growth)
            // Hit 1: 15 bugs, Hit 2: 30 bugs, ..., Hit 10: 150 bugs total
            const totalBugs = state.hitCount * 15;

            // Remove existing bugs
            container.innerHTML = '';

            // Generate random BUG texts all over the screen edges
            for (let i = 0; i < totalBugs; i++) {
                const bugElement = document.createElement('div');
                bugElement.className = 'bug-text';
                bugElement.textContent = 'BUG';

                // Random font size (10px - 30px)
                const fontSize = 10 + Math.random() * 20;
                bugElement.style.fontSize = fontSize + 'px';

                // Random rotation (-30deg to 30deg)
                const rotation = (Math.random() - 0.5) * 60;
                bugElement.style.transform = `rotate(${rotation}deg)`;

                // Decide which edge to place it on
                const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left

                // Progress factor: how far into the screen bugs should penetrate
                // 0 at hit 0, 1.0 at hit 10
                const penetration = (state.hitCount / state.maxHits);

                let x, y;

                if (edge === 0) {
                    // Top edge
                    x = Math.random() * 100; // 0-100%
                    y = Math.random() * 40 * penetration; // Penetrate into screen
                    bugElement.style.left = x + '%';
                    bugElement.style.top = y + '%';
                } else if (edge === 1) {
                    // Right edge
                    x = 100 - Math.random() * 40 * penetration;
                    y = Math.random() * 100;
                    bugElement.style.left = x + '%';
                    bugElement.style.top = y + '%';
                } else if (edge === 2) {
                    // Bottom edge
                    x = Math.random() * 100;
                    y = 100 - Math.random() * 40 * penetration;
                    bugElement.style.left = x + '%';
                    bugElement.style.top = y + '%';
                } else {
                    // Left edge
                    x = Math.random() * 40 * penetration;
                    y = Math.random() * 100;
                    bugElement.style.left = x + '%';
                    bugElement.style.top = y + '%';
                }

                // Random animation delay for staggered glitch effect
                bugElement.style.animationDelay = (Math.random() * 0.3) + 's';

                container.appendChild(bugElement);
            }
        }

        // Play hit sound
        function playHitSound() {
            if (!state.audioContext) return;

            // Harsh alarm sound
            const oscillator = state.audioContext.createOscillator();
            const gainNode = state.audioContext.createGain();

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, state.audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, state.audioContext.currentTime + 0.3);

            gainNode.gain.setValueAtTime(0.3, state.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.3);

            oscillator.connect(gainNode);
            gainNode.connect(state.audioContext.destination);

            oscillator.start();
            oscillator.stop(state.audioContext.currentTime + 0.3);
        }

        // Trigger game over
        function triggerGameOver() {
            state.isGameOver = true;

            // Show game over screen
            document.getElementById('game-over').classList.add('show');

            // Release pointer lock
            document.exitPointerLock();

            // Play game over sound
            playGameOverSound();
        }

        // Show escape success screen
        function showEscapeScreen() {
            if (state.isGameOver) return; // Don't override game over

            console.log('ðŸŽ‰ ESCAPED - You found the EXIT!');

            // Show escape success screen
            document.getElementById('escape-screen').classList.add('show');

            // Release pointer lock
            document.exitPointerLock();

            // Play success sound
            playEscapeSound();
        }

        // Play game over sound
        function playGameOverSound() {
            if (!state.audioContext) return;

            // Dramatic descending tone
            const oscillator = state.audioContext.createOscillator();
            const gainNode = state.audioContext.createGain();

            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, state.audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, state.audioContext.currentTime + 1.5);

            gainNode.gain.setValueAtTime(0.4, state.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 1.5);

            oscillator.connect(gainNode);
            gainNode.connect(state.audioContext.destination);

            oscillator.start();
            oscillator.stop(state.audioContext.currentTime + 1.5);
        }

        // Play escape success sound
        function playEscapeSound() {
            if (!state.audioContext) return;

            // Triumphant ascending tone
            const oscillator = state.audioContext.createOscillator();
            const gainNode = state.audioContext.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(200, state.audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, state.audioContext.currentTime + 0.8);

            gainNode.gain.setValueAtTime(0.3, state.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.8);

            oscillator.connect(gainNode);
            gainNode.connect(state.audioContext.destination);

            oscillator.start();
            oscillator.stop(state.audioContext.currentTime + 0.8);
        }

        // ===========================
        // ANIMATION LOOP
        // ===========================
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Stop updates if game over or escaped
            if (!state.isGameOver && !state.escaped) {
                updateMovement(delta);
                updateMonsters(delta);
                checkCheckpoints(); // Check if player is at a checkpoint
                updateCheckpointEffects(delta); // Update checkpoint lights and EXIT panels
            }

            // Animate flowing text like code stream
            const time = Date.now() * 0.001;
            if (wallTextures.length >= 4) {
                // Right and left walls: flow along corridor (faster)
                wallTextures[0].offset.x = (time * 0.25) % 1; // Right wall - faster flow
                wallTextures[1].offset.x = (time * 0.25) % 1; // Left wall
                wallTextures[0].needsUpdate = true;
                wallTextures[1].needsUpdate = true;

                // Ceiling and floor: flow horizontally (faster)
                wallTextures[2].offset.y = (time * 0.35) % 1; // Ceiling
                wallTextures[3].offset.y = (time * 0.35) % 1; // Floor
                wallTextures[2].needsUpdate = true;
                wallTextures[3].needsUpdate = true;
            }

            // Random flicker
            if (Math.random() > 0.995) {
                const mode = modes[state.currentMode];
                spotlight.intensity = mode.intensity * 0.7;
                setTimeout(() => {
                    spotlight.intensity = mode.intensity;
                }, 100);
            }

            renderer.render(scene, camera);
        }

        // ===========================
        // WINDOW RESIZE
        // ===========================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===========================
        // INITIALIZE
        // ===========================
        window.addEventListener('load', () => {
            console.log('ðŸ”¦ 3D Corridor Flashlight Loading...');
            init();
            console.log('âœ… 3D Scene Ready!');
        });
    </script>
</body>
</html>
