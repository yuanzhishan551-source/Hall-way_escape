<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Corridor Flashlight - 3D First Person</title>
    <!-- Version: 2.0 - Enhanced Monster Count & BUG Invasion System -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #000;
            overflow: hidden;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* UI Overlay */
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 16px;
            z-index: 100;
            text-shadow: 0 0 10px #00ff00;
            pointer-events: none;
            font-family: monospace;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border: 2px solid #00ff00;
        }

        #mode-indicator {
            font-size: 20px;
            margin-bottom: 10px;
        }

        #instructions {
            font-size: 12px;
            opacity: 0.8;
            line-height: 1.5;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 50;
        }

        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }

        #crosshair::before {
            width: 2px;
            height: 100%;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 100%;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }


        /* BUG Invasion overlay - random scattered bugs */
        #bug-invasion {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 60;
            font-family: monospace;
            color: #ff0000;
            font-weight: bold;
            overflow: hidden;
        }

        .bug-text {
            position: absolute;
            text-shadow: 0 0 8px #ff0000, 0 0 12px #ff0000;
            opacity: 0.95;
            white-space: nowrap;
            animation: bugGlitch 0.3s infinite;
        }

        @keyframes bugGlitch {
            0%, 100% {
                text-shadow: 0 0 8px #ff0000, 0 0 12px #ff0000;
                opacity: 0.95;
            }
            50% {
                text-shadow: 2px 2px 8px #ff0000, -2px -2px 12px #ff0000;
                opacity: 0.85;
            }
        }

        /* Hit flash effect */
        #hit-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 0, 0, 0);
            pointer-events: none;
            z-index: 70;
            transition: background 0.1s;
        }

        .flash-hit {
            background: rgba(255, 0, 0, 0.5) !important;
        }

        /* Game Over screen */
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: #ff0000;
            font-size: 48px;
            text-shadow: 0 0 30px #ff0000;
        }

        #game-over.show {
            display: flex;
        }

        #game-over-text {
            animation: glitch 0.5s infinite;
        }

        @keyframes glitch {
            0%, 100% { transform: translate(0); }
            20% { transform: translate(-5px, 5px); }
            40% { transform: translate(5px, -5px); }
            60% { transform: translate(-5px, -5px); }
            80% { transform: translate(5px, 5px); }
        }

        .restart-btn {
            margin-top: 30px;
            font-size: 20px;
            padding: 15px 30px;
            background: #ff0000;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: monospace;
            font-weight: bold;
        }

        .restart-btn:hover {
            background: #ff3333;
        }

        /* Escape Success screen */
        #escape-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
            color: #00ff00;
            font-size: 48px;
            text-shadow: 0 0 30px #00ff00;
        }

        #escape-screen.show {
            display: flex;
        }

        #escape-text {
            animation: fadeIn 2s ease-in;
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: scale(0.8); }
            100% { opacity: 1; transform: scale(1); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Hit Flash Effect -->
    <div id="hit-flash"></div>

    <!-- BUG Invasion Overlay -->
    <div id="bug-invasion"></div>

    <!-- Game Over Screen -->
    <div id="game-over">
        <div id="game-over-text">SYSTEM CORRUPTED</div>
        <div style="font-size: 24px; margin-top: 20px;">BUG OVERFLOW</div>
        <button class="restart-btn" onclick="location.reload()">RESTART</button>
    </div>

    <!-- Escape Success Screen -->
    <div id="escape-screen">
        <div id="escape-text">ESCAPED</div>
        <div style="font-size: 24px; margin-top: 20px;">You found the EXIT</div>
        <button class="restart-btn" style="background: #00ff00; color: #000;" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <!-- Crosshair -->
    <div id="crosshair"></div>

    <!-- UI Overlay -->
    <div id="ui-overlay">
        <div id="mode-indicator">MODE: WIDE BEAM</div>
        <div id="instructions">
            WASD: Move<br>
            MOUSE: Look Around<br>
            CLICK: Switch Mode<br>
            ESC: Unlock Mouse
        </div>
    </div>

    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // ===========================
        // GLOBAL STATE
        // ===========================
        const state = {
            currentMode: 0,
            isLocked: false,
            monsters: [],
            moveForward: false,
            moveBackward: false,
            moveLeft: false,
            moveRight: false,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            audioContext: null,
            hitCount: 0,
            maxHits: 10,
            isGameOver: false,
            escaped: false,
            velocityY: 0,  // Vertical velocity for falling
            isGrounded: true,  // Whether player is on ground
            lastHitTime: 0,
            invulnerableTime: 1.0 // 1 second invulnerability after hit
        };

        // Mode configurations
        const modes = [
            {
                name: 'WIDE BEAM',
                color: 0xff0000,
                colorHex: '#ff0000',
                intensity: 2.5,
                distance: 25,
                angle: Math.PI / 4,
                penumbra: 0.5
            },
            {
                name: 'DETECTION',
                color: 0x00ff00,
                colorHex: '#00ff00',
                intensity: 1.8,
                distance: 30,
                angle: Math.PI / 6,
                penumbra: 0.4
            }
        ];

        // ===========================
        // SCENE SETUP
        // ===========================
        let scene, camera, renderer, spotlight, flashlightGroup;
        let corridor, monsters = [];
        let clock = new THREE.Clock();
        let wallTextures = []; // Store textures for animation

        // Intersection system
        let corridorSegments = [];
        let intersections = [];
        let correctPathCount = 0; // Track correct turns
        let currentDirection = new THREE.Vector3(0, 0, -1); // Player facing direction
        let playerRotation = 0; // Player Y rotation in radians

        // Wall text for textures
        const wallText = `RUN ESCAPE DANGER GET OUT FLEE WARNING EXIT HURRY # | / \\ - + = * : . X H M W N data information technology digital world artificial intelligence machine learning algorithm code programming software development BUG ERROR SYSTEM CORRUPTED`;

        // Shared texture cache for performance
        let sharedWallTexture = null;

        // Checkpoint system - infinite generation
        let checkpoints = [];
        let nextCheckpointZ = -100;
        const CHECKPOINT_INTERVAL = 100;
        let currentCheckpoint = null;
        let atCheckpoint = false;
        let exitRevealed = false; // Track if exit is revealed by green light
        let lastWallEndZ = 80; // Track where the last wall segment ended

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a0a, 1, 50);

            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 0); // Eye level height

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: false }); // No antialiasing for pixelated look
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio * 0.7); // Lower pixel ratio for pixelated effect
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.BasicShadowMap; // Pixelated shadows
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Ambient light (increased for visibility)
            const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.3);
            scene.add(ambientLight);

            // Create flashlight group (moves with camera)
            flashlightGroup = new THREE.Group();
            camera.add(flashlightGroup);
            scene.add(camera);

            // Spotlight (flashlight)
            spotlight = new THREE.SpotLight(
                modes[0].color,
                modes[0].intensity,
                modes[0].distance,
                modes[0].angle,
                modes[0].penumbra
            );
            spotlight.position.set(0, -0.2, -0.5);
            spotlight.target.position.set(0, -0.2, -5);
            spotlight.castShadow = true;
            spotlight.shadow.mapSize.width = 512; // Lower resolution for pixelated shadows
            spotlight.shadow.mapSize.height = 512;

            flashlightGroup.add(spotlight);
            flashlightGroup.add(spotlight.target);

            // Initialize audio
            initAudio();

            // Create shared wall texture once (performance optimization)
            sharedWallTexture = createTextTexture(wallText);

            // Create corridor
            createCorridor();

            // Create initial monsters (reduced for performance)
            createMonster();
            createMonster();
            setInterval(() => {
                if (monsters.length < 8) { // Reduced from 25 to 8 for performance
                    createMonster();
                }
            }, 2500); // Slower spawn for performance

            // Setup controls
            setupControls();

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);

            // Start animation loop
            animate();
        }

        // ===========================
        // CREATE TEXT TEXTURE - CONTINUOUS LONG TEXT
        // ===========================
        function createTextTexture(text, width = 4096, height = 4096) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);

            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 96px Courier New'; // Increased font size

            // Create very long continuous text by repeating characters (no spaces)
            const chars = text.replace(/ /g, ''); // Remove all spaces from source
            let longText = '';
            for (let i = 0; i < 3000; i++) { // More characters to fill canvas completely
                longText += chars.charAt(Math.floor(Math.random() * chars.length));
            }

            let y = 96; // Start from top (font size)
            let x = 0; // No left margin
            const lineHeight = 130; // Wider line spacing for better readability

            // Fill the entire canvas with continuous text character by character (zero spacing)
            for (let i = 0; i < longText.length; i++) {
                const char = longText.charAt(i);
                const metrics = ctx.measureText(char);

                if (x + metrics.width > width) { // Fill to right edge
                    x = 0;
                    y += lineHeight;
                    if (y > height) break; // Fill to bottom edge
                }

                ctx.fillText(char, x, y);
                x += metrics.width; // Exact character width, no extra spacing
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // ===========================
        // CREATE 3D CORRIDOR WITH INTERSECTIONS
        // ===========================
        function createCorridor() {
            // Use shared texture for performance
            const textTexture = sharedWallTexture;

            // Corridor dimensions
            const corridorWidth = 6;
            const corridorHeight = 10;
            const corridorLength = 500;

            // Intersection positions (where openings will be)
            const intersectionPositions = [-100, -200, -300];
            const intersectionWidth = 4; // Width of opening

            // Create floor (one continuous piece)
            const floorTexture = textTexture.clone();
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(1, 100);
            floorTexture.needsUpdate = true;
            wallTextures.push(floorTexture);

            const floorGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
            const floorMaterial = new THREE.MeshStandardMaterial({
                map: floorTexture,
                side: THREE.DoubleSide,
                emissive: 0x555555,
                emissiveMap: floorTexture,
                emissiveIntensity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -5;
            scene.add(floor);

            // Create ceiling (one continuous piece)
            const ceilingTexture = textTexture.clone();
            ceilingTexture.wrapS = THREE.RepeatWrapping;
            ceilingTexture.wrapT = THREE.RepeatWrapping;
            ceilingTexture.repeat.set(1, 100);
            ceilingTexture.needsUpdate = true;
            wallTextures.push(ceilingTexture);

            const ceilingGeometry = new THREE.PlaneGeometry(corridorWidth, corridorLength);
            const ceilingMaterial = new THREE.MeshStandardMaterial({
                map: ceilingTexture,
                side: THREE.DoubleSide,
                emissive: 0x555555,
                emissiveMap: ceilingTexture,
                emissiveIntensity: 0.8
            });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = -Math.PI / 2;
            ceiling.position.y = 5;
            scene.add(ceiling);

            // Initial wall segment from start to first checkpoint area
            const initialSegment = { start: 250, end: 80 };
            createWallSegment(initialSegment.start, initialSegment.end, textTexture);

            // Front wall (end of corridor)
            const frontWallTexture = textTexture.clone();
            frontWallTexture.wrapS = THREE.RepeatWrapping;
            frontWallTexture.wrapT = THREE.RepeatWrapping;
            frontWallTexture.repeat.set(2, 2);
            frontWallTexture.needsUpdate = true;
            wallTextures.push(frontWallTexture);

            const frontWallGeometry = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
            const frontWallMaterial = new THREE.MeshStandardMaterial({
                map: frontWallTexture,
                side: THREE.DoubleSide,
                emissive: 0x555555,
                emissiveMap: frontWallTexture,
                emissiveIntensity: 0.8
            });
            const frontWall = new THREE.Mesh(frontWallGeometry, frontWallMaterial);
            frontWall.position.z = 250;
            scene.add(frontWall);

            // Back wall (start of corridor - where exit door will be)
            const backWallTexture = textTexture.clone();
            backWallTexture.wrapS = THREE.RepeatWrapping;
            backWallTexture.wrapT = THREE.RepeatWrapping;
            backWallTexture.repeat.set(2, 2);
            backWallTexture.needsUpdate = true;
            wallTextures.push(backWallTexture);

            const backWallGeometry = new THREE.PlaneGeometry(corridorWidth, corridorHeight);
            const backWallMaterial = new THREE.MeshStandardMaterial({
                map: backWallTexture,
                side: THREE.DoubleSide,
                emissive: 0x555555,
                emissiveMap: backWallTexture,
                emissiveIntensity: 0.8
            });
            const backWall = new THREE.Mesh(backWallGeometry, backWallMaterial);
            backWall.position.z = -250;
            scene.add(backWall);

            // Exit door will be created after 3 correct choices
            // createExitDoor(500, 6, 10);

            // Generate initial checkpoint (only one per segment)
            generateCheckpoint();
        }

        // ===========================
        // HELPER FUNCTIONS FOR GEOMETRY CREATION
        // ===========================
        function createTexture(baseTexture, repeatX, repeatY) {
            const tex = baseTexture.clone();
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(repeatX, repeatY);
            tex.needsUpdate = true;
            wallTextures.push(tex);
            return tex;
        }

        function createWallMaterial(texture) {
            return new THREE.MeshStandardMaterial({
                map: texture,
                side: THREE.DoubleSide,
                emissive: 0x555555,
                emissiveMap: texture,
                emissiveIntensity: 0.8
            });
        }

        function createPlane(width, height, texture, x, y, z, rotX = 0, rotY = 0) {
            const geometry = new THREE.PlaneGeometry(width, height);
            const material = createWallMaterial(texture);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            if (rotX) mesh.rotation.x = rotX;
            if (rotY) mesh.rotation.y = rotY;
            return mesh;
        }

        // ===========================
        // CREATE WALL SEGMENT
        // ===========================
        function createWallSegment(startZ, endZ, baseTexture) {
            const segmentLength = Math.abs(endZ - startZ);
            const segmentCenter = (startZ + endZ) / 2;
            const tex = createTexture(baseTexture, segmentLength / 10, 2);

            scene.add(createPlane(segmentLength, 10, tex, 3, 0, segmentCenter, 0, -Math.PI / 2));
            scene.add(createPlane(segmentLength, 10, createTexture(baseTexture, segmentLength / 10, 2), -3, 0, segmentCenter, 0, -Math.PI / 2));
        }

        // ===========================
        // CREATE BRANCH CORRIDOR
        // ===========================
        function createBranchCorridor(centerX, endX, z) {
            const group = new THREE.Group();
            const rotX = -Math.PI / 2;
            const rotY = Math.PI / 2;

            // Floor with hole at the end (12m floor + 3m hole)
            // Left branch: floor from X=-3 to X=-15 (center at -9), hole from -15 to -18
            // Right branch: floor from X=3 to X=15 (center at 9), hole from 15 to 18
            const floorCenterX = endX > 0 ? 9 : -9; // Shifted toward entrance
            const floor = createPlane(12, 3, createTexture(sharedWallTexture, 4, 1), floorCenterX, -5, z, rotX);
            group.add(floor);

            // Full Ceiling (covers entire 15m)
            group.add(createPlane(15, 3, createTexture(sharedWallTexture, 5, 1), centerX, 5, z, rotX));

            // Front & Back walls - shifted 100px (1m) away from main corridor
            // Left branch: walls at Z offset by -1m (back) and +1m (front) from intersection
            // Right branch: same Z offset
            const wallLength = 15; // Full length
            const wallCenterX = endX > 0 ? 10.5 : -10.5;

            // Back wall - shifted further back (away from player's approach)
            const backWallZ = endX > 0 ? z - 2.5 : z - 2.5; // 1m extra shift
            group.add(createPlane(wallLength, 10, createTexture(sharedWallTexture, 5, 2), wallCenterX, 0, backWallZ));

            // Front wall - shifted further forward
            const frontWallZ = endX > 0 ? z + 2.5 : z + 2.5; // 1m extra shift
            group.add(createPlane(wallLength, 10, createTexture(sharedWallTexture, 5, 2), wallCenterX, 0, frontWallZ));

            // End wall (at the dead end where the hole is)
            group.add(createPlane(3, 10, createTexture(sharedWallTexture, 1, 2), endX, 0, z, 0, rotY));

            scene.add(group);
            return group;
        }

        // ===========================
        // GENERATE SINGLE CHECKPOINT
        // ===========================
        function generateCheckpoint() {
            // Create new checkpoint
            const checkpoint = {
                z: nextCheckpointZ,
                passed: false,
                correctChoice: Math.random() > 0.5 ? 'left' : 'right',
                exitPanel: null,
                leftDoor: null,
                rightDoor: null,
                leftBlock: null,
                rightBlock: null,
                light: null
            };

            const index = checkpoints.length;

            // No visual marker - player must find the intersection naturally

            // Create EXIT text panel on correct wall (initially invisible)
            const exitCanvas = document.createElement('canvas');
            exitCanvas.width = 1024;
            exitCanvas.height = 512;
            const exitCtx = exitCanvas.getContext('2d');

            // Green glowing background
            exitCtx.fillStyle = '#00ff00';
            exitCtx.shadowBlur = 30;
            exitCtx.shadowColor = '#00ff00';
            exitCtx.fillRect(0, 0, exitCanvas.width, exitCanvas.height);

            // Black EXIT text
            exitCtx.shadowBlur = 0;
            exitCtx.fillStyle = '#000000';
            exitCtx.font = 'bold 200px monospace';
            exitCtx.textAlign = 'center';
            exitCtx.textBaseline = 'middle';
            exitCtx.fillText('EXIT', exitCanvas.width / 2, exitCanvas.height / 2);

            // Arrow pointing forward
            exitCtx.font = 'bold 100px monospace';
            exitCtx.fillText('â†“', exitCanvas.width / 2, exitCanvas.height / 2 + 150);

            const exitTexture = new THREE.CanvasTexture(exitCanvas);
            exitTexture.magFilter = THREE.NearestFilter;
            exitTexture.minFilter = THREE.NearestFilter;

            const exitGeometry = new THREE.PlaneGeometry(4, 2);
            const exitMaterial = new THREE.MeshStandardMaterial({
                map: exitTexture,
                transparent: true,
                opacity: 0, // Start invisible
                emissive: 0x00ff00,
                emissiveIntensity: 1.0,
                side: THREE.DoubleSide
            });

            const exitPanel = new THREE.Mesh(exitGeometry, exitMaterial);

            // Position on correct wall
            if (checkpoint.correctChoice === 'left') {
                exitPanel.position.set(-2.9, 3, checkpoint.z); // Left wall
                exitPanel.rotation.y = Math.PI / 2;
            } else {
                exitPanel.position.set(2.9, 3, checkpoint.z); // Right wall
                exitPanel.rotation.y = -Math.PI / 2;
            }

            scene.add(exitPanel);
            checkpoint.exitPanel = exitPanel;

            // Create branch corridors using helper function
            checkpoint.leftDoor = createBranchCorridor(-10.5, -18, checkpoint.z);
            checkpoint.rightDoor = createBranchCorridor(10.5, 18, checkpoint.z);

            // Create blocking walls (initially invisible, will appear for wrong choices)
            const blockWallGeometry = new THREE.PlaneGeometry(3, 8);
            const blockWallMaterial = new THREE.MeshStandardMaterial({
                color: 0x330000,
                transparent: true,
                opacity: 0,
                emissive: 0xff0000,
                emissiveIntensity: 0
            });

            // Left blocking wall
            const leftBlock = new THREE.Mesh(blockWallGeometry, blockWallMaterial.clone());
            leftBlock.position.set(-2.95, 4, checkpoint.z);
            leftBlock.rotation.y = Math.PI / 2;
            scene.add(leftBlock);
            checkpoint.leftBlock = leftBlock;

            // Right blocking wall
            const rightBlock = new THREE.Mesh(blockWallGeometry, blockWallMaterial.clone());
            rightBlock.position.set(2.95, 4, checkpoint.z);
            rightBlock.rotation.y = -Math.PI / 2;
            scene.add(rightBlock);
            checkpoint.rightBlock = rightBlock;

            // Generate wall segment from last wall end to this checkpoint
            const openingHalfWidth = 1.5;
            const wallStartZ = lastWallEndZ;
            const wallEndZ = checkpoint.z + openingHalfWidth;

            if (wallStartZ > wallEndZ) {
                // Create wall segment before this checkpoint
                createWallSegment(wallStartZ, wallEndZ, sharedWallTexture);
            }

            // Create back wall of main corridor at checkpoint (dead end)
            // This closes off the main corridor - player MUST choose left or right
            const endWallZ = checkpoint.z - 1.5; // Back wall of intersection
            const endWallTex = createTexture(sharedWallTexture, 2, 2);
            checkpoint.backWall = createPlane(6, 10, endWallTex, 0, 0, endWallZ);
            scene.add(checkpoint.backWall);

            // Create small connector walls at front of intersection (where branches start)
            const frontWallZ = checkpoint.z + 1.5;
            const frontTex = createTexture(sharedWallTexture, 0.3, 2);
            checkpoint.connectorWalls = [];
            // Left side connector (x=-3 to x=-0.5)
            const leftConnector = createPlane(2.5, 10, frontTex, -1.75, 0, frontWallZ);
            scene.add(leftConnector);
            checkpoint.connectorWalls.push(leftConnector);
            // Right side connector (x=0.5 to x=3)
            const rightConnector = createPlane(2.5, 10, createTexture(sharedWallTexture, 0.3, 2), 1.75, 0, frontWallZ);
            scene.add(rightConnector);
            checkpoint.connectorWalls.push(rightConnector);

            // Main corridor ends here - player must choose left or right branch

            // Add checkpoint to array and update next position
            checkpoints.push(checkpoint);
            nextCheckpointZ -= CHECKPOINT_INTERVAL;
        }

        // ===========================
        // CREATE EXIT DOOR
        // ===========================
        function createExitDoor(length, width, height) {
            const doorGroup = new THREE.Group();

            // Door position at the end of corridor
            const doorZ = -length / 2 + 0.5; // Slight offset from wall

            // Door frame (black)
            const doorGeometry = new THREE.BoxGeometry(2, 3, 0.2);
            const doorMaterial = new THREE.MeshStandardMaterial({
                color: 0x0a0a0a,
                roughness: 0.8,
                metalness: 0.2
            });
            const door = new THREE.Mesh(doorGeometry, doorMaterial);
            door.position.set(0, 1.5, doorZ);
            door.receiveShadow = true;
            door.castShadow = true;
            doorGroup.add(door);

            // Door handle (darker gray)
            const handleGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.1);
            const handleMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                roughness: 0.5,
                metalness: 0.5
            });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.set(0.7, 1.5, doorZ + 0.15);
            doorGroup.add(handle);

            // EXIT sign (green glowing)
            const signCanvas = document.createElement('canvas');
            signCanvas.width = 256;
            signCanvas.height = 128;
            const ctx = signCanvas.getContext('2d');

            // Green background
            ctx.fillStyle = '#00aa00';
            ctx.fillRect(0, 0, signCanvas.width, signCanvas.height);

            // White border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.strokeRect(5, 5, signCanvas.width - 10, signCanvas.height - 10);

            // EXIT text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 72px monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('EXIT', signCanvas.width / 2, signCanvas.height / 2);

            // Running man icon (simple representation)
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(60, 64, 12, 0, Math.PI * 2); // Head
            ctx.fill();
            ctx.fillRect(55, 76, 10, 20); // Body
            ctx.fillRect(50, 80, 5, 15); // Left leg
            ctx.fillRect(65, 80, 5, 15); // Right leg

            const signTexture = new THREE.CanvasTexture(signCanvas);
            signTexture.magFilter = THREE.NearestFilter;
            signTexture.minFilter = THREE.NearestFilter;

            const signGeometry = new THREE.PlaneGeometry(1.5, 0.75);
            const signMaterial = new THREE.MeshStandardMaterial({
                map: signTexture,
                emissive: 0x00ff00,
                emissiveIntensity: 0.5
            });
            const sign = new THREE.Mesh(signGeometry, signMaterial);
            sign.position.set(0, 3.3, doorZ + 0.1);
            doorGroup.add(sign);

            // Green light from sign
            const signLight = new THREE.PointLight(0x00ff00, 0.5, 5);
            signLight.position.set(0, 3.3, doorZ + 0.5);
            doorGroup.add(signLight);

            scene.add(doorGroup);
        }

        // ===========================
        // CREATE TEXT MONSTERS (CLUSTERS)
        // ===========================
        function createMonster() {
            const monsterTexts = ['BUG']; // Only use BUG

            // Create a group for the monster cluster
            const monsterCluster = new THREE.Group();

            // Determine monster type
            const monsterType = Math.random() > 0.6 ? 'green' : 'red';
            const baseColor = monsterType === 'red' ? '#ff0000' : '#00ff00';

            // Create 10-20 text fragments in a cluster (reduced for performance)
            const fragmentCount = Math.floor(Math.random() * 11) + 10; // 10-20 fragments (was 40-60)

            for (let i = 0; i < fragmentCount; i++) {
                const text = monsterTexts[Math.floor(Math.random() * monsterTexts.length)];

                // Create text sprite
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // Vary opacity and size for depth
                const alpha = 0.6 + Math.random() * 0.4;
                ctx.fillStyle = baseColor;
                ctx.font = `bold ${32 + Math.floor(Math.random() * 24)}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Add glow
                ctx.shadowBlur = 15 + Math.random() * 10;
                ctx.shadowColor = baseColor;
                ctx.fillText(text, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                texture.magFilter = THREE.NearestFilter;
                texture.minFilter = THREE.NearestFilter;

                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    opacity: monsterType === 'green' ? 0.2 : alpha // Green monsters nearly invisible
                });

                const sprite = new THREE.Sprite(spriteMaterial);

                // Random position within cluster (1x1x1 cube - much tighter)
                sprite.position.set(
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1,
                    (Math.random() - 0.5) * 1
                );

                // Random scale
                const scale = 0.8 + Math.random() * 0.6;
                sprite.scale.set(scale * 1.5, scale * 0.4, 1);

                // Store individual fragment animation data
                sprite.userData = {
                    floatOffset: Math.random() * Math.PI * 2,
                    floatSpeed: 0.5 + Math.random() * 0.5
                };

                monsterCluster.add(sprite);
            }

            // Position cluster in corridor (far away from player in 500m corridor)
            monsterCluster.position.set(
                (Math.random() - 0.5) * 4,
                1.5 + Math.random() * 1,
                -50 - Math.random() * 400 // Start far away in long corridor
            );

            // Store cluster data
            monsterCluster.userData = {
                type: monsterType,
                baseOpacity: monsterType === 'green' ? 0.2 : 0.8,
                pulsePhase: Math.random() * Math.PI * 2,
                rotationSpeed: (Math.random() - 0.5) * 0.3,
                approachSpeed: 0.01 + Math.random() * 0.02, // Speed towards player
                frozen: false,
                freezeTimer: 0,
                revealed: false,
                disintegrating: false
            };

            scene.add(monsterCluster);
            monsters.push(monsterCluster);
        }

        // ===========================
        // CONTROLS
        // ===========================
        function setupControls() {
            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW': state.moveForward = true; break;
                    case 'KeyS': state.moveBackward = true; break;
                    case 'KeyA': state.moveLeft = true; break;
                    case 'KeyD': state.moveRight = true; break;
                    case 'KeyQ':
                        if (atCheckpoint && currentCheckpoint) {
                            handleCheckpointChoice('left');
                        }
                        break;
                    case 'KeyE':
                        if (atCheckpoint && currentCheckpoint) {
                            handleCheckpointChoice('right');
                        }
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW': state.moveForward = false; break;
                    case 'KeyS': state.moveBackward = false; break;
                    case 'KeyA': state.moveLeft = false; break;
                    case 'KeyD': state.moveRight = false; break;
                }
            });

            // Mouse look - request pointer lock on first click
            renderer.domElement.addEventListener('click', () => {
                if (!state.isLocked) {
                    renderer.domElement.requestPointerLock();
                }
            }, { once: true });

            document.addEventListener('pointerlockchange', () => {
                state.isLocked = document.pointerLockElement === renderer.domElement;
            });

            document.addEventListener('mousemove', (e) => {
                if (!state.isLocked) return;

                const movementX = e.movementX || 0;
                const movementY = e.movementY || 0;

                camera.rotation.y -= movementX * 0.002;
                camera.rotation.x -= movementY * 0.002;

                // Clamp vertical rotation
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            });

            // Click to switch mode
            document.addEventListener('click', () => {
                if (state.isLocked) {
                    switchMode();
                }
            });
        }

        // ===========================
        // SWITCH FLASHLIGHT MODE
        // ===========================
        function switchMode() {
            state.currentMode = (state.currentMode + 1) % modes.length;
            const mode = modes[state.currentMode];

            spotlight.color.setHex(mode.color);
            spotlight.intensity = mode.intensity;
            spotlight.distance = mode.distance;
            spotlight.angle = mode.angle;
            spotlight.penumbra = mode.penumbra;

            document.getElementById('mode-indicator').textContent = `MODE: ${mode.name}`;
            document.getElementById('mode-indicator').style.color = mode.colorHex;

            // Flicker effect
            spotlight.intensity *= 1.5;
            setTimeout(() => {
                spotlight.intensity = mode.intensity;
            }, 100);
        }

        // ===========================
        // CHECKPOINT SYSTEM
        // ===========================
        function handleCheckpointChoice(choice) {
            if (!currentCheckpoint || currentCheckpoint.passed) return;

            currentCheckpoint.passed = true;
            atCheckpoint = false;

            if (choice === currentCheckpoint.correctChoice) {
                correctPathCount++;
                console.log(`âœ… Correct choice! Progress: ${correctPathCount}/3`);

                // Update UI
                document.getElementById('mode-indicator').textContent = `CORRECT PATHS: ${correctPathCount}/3`;
                document.getElementById('mode-indicator').style.color = '#00ff00';

                setTimeout(() => {
                    document.getElementById('mode-indicator').textContent = `MODE: ${modes[state.currentMode].name}`;
                    document.getElementById('mode-indicator').style.color = modes[state.currentMode].colorHex;
                }, 2000);

                // Block the wrong path - close the door with red wall
                if (choice === 'left') {
                    // Block right door
                    if (currentCheckpoint.rightBlock) {
                        currentCheckpoint.rightBlock.material.opacity = 0.9;
                        currentCheckpoint.rightBlock.material.emissiveIntensity = 0.5;
                    }
                } else {
                    // Block left door
                    if (currentCheckpoint.leftBlock) {
                        currentCheckpoint.leftBlock.material.opacity = 0.9;
                        currentCheckpoint.leftBlock.material.emissiveIntensity = 0.5;
                    }
                }

                // Check if all 3 correct - create exit door
                if (correctPathCount >= 3) {
                    createExitDoor(500, 6, 10);
                    console.log('ðŸšª Exit door appeared!');
                }
            } else {
                console.log(`âŒ Wrong choice. Progress: ${correctPathCount}/3`);

                // Flash red
                document.getElementById('mode-indicator').textContent = `WRONG PATH`;
                document.getElementById('mode-indicator').style.color = '#ff0000';

                setTimeout(() => {
                    document.getElementById('mode-indicator').textContent = `MODE: ${modes[state.currentMode].name}`;
                    document.getElementById('mode-indicator').style.color = modes[state.currentMode].colorHex;
                }, 2000);

                // Block the chosen wrong path
                if (choice === 'left') {
                    if (currentCheckpoint.leftBlock) {
                        currentCheckpoint.leftBlock.material.opacity = 0.9;
                        currentCheckpoint.leftBlock.material.emissiveIntensity = 0.5;
                    }
                } else {
                    if (currentCheckpoint.rightBlock) {
                        currentCheckpoint.rightBlock.material.opacity = 0.9;
                        currentCheckpoint.rightBlock.material.emissiveIntensity = 0.5;
                    }
                }
            }

            currentCheckpoint = null;
        }

        function checkCheckpoints() {
            // Check if player is near any checkpoint
            for (let cp of checkpoints) {
                if (!cp.passed && Math.abs(camera.position.z - cp.z) < 10) {
                    if (!atCheckpoint) {
                        atCheckpoint = true;
                        currentCheckpoint = cp;
                        console.log('ðŸ“ Checkpoint reached! Press Q (left) or E (right)');

                        // Update UI
                        document.getElementById('instructions').innerHTML = `
                            CHECKPOINT!<br>
                            Q: Choose LEFT<br>
                            E: Choose RIGHT<br>
                            Progress: ${correctPathCount}/3<br>
                            <span style="color: #00ff00;">Use GREEN light to reveal EXIT</span>
                        `;
                    }
                    return;
                }
            }

            // Player left checkpoint area
            if (atCheckpoint && currentCheckpoint && Math.abs(camera.position.z - currentCheckpoint.z) > 15) {
                atCheckpoint = false;
                currentCheckpoint = null;

                // Reset UI
                document.getElementById('instructions').innerHTML = `
                    WASD: Move<br>
                    MOUSE: Look Around<br>
                    CLICK: Switch Mode<br>
                    ESC: Unlock Mouse
                `;
            }
        }

        // ===========================
        // UPDATE CHECKPOINT EFFECTS
        // ===========================
        function updateCheckpointEffects(delta) {
            const time = Date.now() * 0.001;

            checkpoints.forEach(checkpoint => {
                // Check if green light is revealing EXIT panel
                if (checkpoint.exitPanel && !checkpoint.passed &&
                    state.currentMode === 1 && atCheckpoint && currentCheckpoint === checkpoint) {

                    // Check if player is looking at the correct wall
                    const distanceToPanel = checkpoint.exitPanel.position.distanceTo(camera.position);

                    if (distanceToPanel < 15) { // Within reasonable viewing distance
                        // Get direction camera is looking
                        const cameraDirection = new THREE.Vector3(0, 0, -1);
                        cameraDirection.applyQuaternion(camera.quaternion);

                        // Get direction to EXIT panel
                        const toPanelDirection = new THREE.Vector3();
                        toPanelDirection.subVectors(checkpoint.exitPanel.position, camera.position);
                        toPanelDirection.normalize();

                        // Calculate angle
                        const angle = Math.acos(cameraDirection.dot(toPanelDirection));

                        // If looking at panel (within 45 degrees), reveal it
                        if (angle < Math.PI / 4) {
                            // Fade in EXIT panel
                            checkpoint.exitPanel.material.opacity = Math.min(
                                checkpoint.exitPanel.material.opacity + delta * 2,
                                1.0
                            );
                        } else {
                            // Fade out when not looking
                            checkpoint.exitPanel.material.opacity = Math.max(
                                checkpoint.exitPanel.material.opacity - delta * 3,
                                0
                            );
                        }
                    } else {
                        // Fade out when too far
                        checkpoint.exitPanel.material.opacity = Math.max(
                            checkpoint.exitPanel.material.opacity - delta * 3,
                            0
                        );
                    }
                } else if (checkpoint.exitPanel && checkpoint.exitPanel.material.opacity > 0) {
                    // Fade out if not at checkpoint or not using green light
                    checkpoint.exitPanel.material.opacity = Math.max(
                        checkpoint.exitPanel.material.opacity - delta * 3,
                        0
                    );
                }
            });
        }

        // ===========================
        // UPDATE MOVEMENT
        // ===========================
        function updateMovement(delta) {
            if (!state.isLocked || state.isGameOver) return;

            const speed = 5.0;
            const gravity = -20.0; // Gravity acceleration

            // Store old position for collision detection
            const oldX = camera.position.x;
            const oldZ = camera.position.z;
            const oldY = camera.position.y;

            // Calculate forward and right vectors based on camera rotation
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();

            // Forward direction (where camera is looking in XZ plane)
            forward.set(
                -Math.sin(camera.rotation.y),
                0,
                -Math.cos(camera.rotation.y)
            );

            // Right direction (perpendicular to forward in XZ plane)
            right.set(
                Math.cos(camera.rotation.y),
                0,
                -Math.sin(camera.rotation.y)
            );

            // Apply movement based on WASD
            if (state.moveForward) {
                camera.position.x += forward.x * speed * delta;
                camera.position.z += forward.z * speed * delta;
            }
            if (state.moveBackward) {
                camera.position.x -= forward.x * speed * delta;
                camera.position.z -= forward.z * speed * delta;
            }
            if (state.moveLeft) {
                camera.position.x -= right.x * speed * delta;
                camera.position.z -= right.z * speed * delta;
            }
            if (state.moveRight) {
                camera.position.x += right.x * speed * delta;
                camera.position.z += right.z * speed * delta;
            }

            // Collision detection and boundary checking
            let inBranch = false;
            let nearIntersection = false;

            // Check if player is in a branch corridor
            for (let checkpoint of checkpoints) {
                const distToCheckpoint = Math.abs(camera.position.z - checkpoint.z);

                // Check if in left branch
                if (distToCheckpoint < 2 && camera.position.x < -3) {
                    inBranch = true;
                    // Constrain to left branch bounds
                    camera.position.x = Math.max(-18, Math.min(-0.5, camera.position.x));
                    camera.position.z = Math.max(checkpoint.z - 1.5, Math.min(checkpoint.z + 1.5, camera.position.z));

                    // Check collision with branch end wall
                    if (camera.position.x < -17.5) {
                        camera.position.x = -17.5;
                    }
                    break;
                }
                // Check if in right branch
                else if (distToCheckpoint < 2 && camera.position.x > 3) {
                    inBranch = true;
                    // Constrain to right branch bounds
                    camera.position.x = Math.max(0.5, Math.min(18, camera.position.x));
                    camera.position.z = Math.max(checkpoint.z - 1.5, Math.min(checkpoint.z + 1.5, camera.position.z));

                    // Check collision with branch end wall
                    if (camera.position.x > 17.5) {
                        camera.position.x = 17.5;
                    }
                    break;
                }
                // Near intersection but not in branch
                else if (distToCheckpoint < 5) {
                    nearIntersection = true;
                }
            }

            // If not in branch, apply main corridor bounds
            if (!inBranch) {
                if (nearIntersection) {
                    // Allow wider movement near intersections
                    camera.position.x = Math.max(-20, Math.min(20, camera.position.x));
                } else {
                    // Normal corridor width
                    camera.position.x = Math.max(-2.5, Math.min(2.5, camera.position.x));
                }

                // Main corridor length bounds
                // Only limit forward movement (z=245), allow infinite backward movement
                camera.position.z = Math.min(245, camera.position.z);
            }

            // Apply gravity and check for ground
            const groundLevel = 0; // Normal floor height
            let hasFloor = true;

            // Check if player is in fall zone (at end of branch corridor)
            for (let checkpoint of checkpoints) {
                const distToCheckpoint = Math.abs(camera.position.z - checkpoint.z);

                // If in left branch fall zone
                if (distToCheckpoint < 2 && camera.position.x < -15) {
                    hasFloor = false;
                    break;
                }
                // If in right branch fall zone
                else if (distToCheckpoint < 2 && camera.position.x > 15) {
                    hasFloor = false;
                    break;
                }
            }

            if (hasFloor) {
                // Player is on solid ground
                if (camera.position.y < groundLevel) {
                    camera.position.y = groundLevel;
                    state.velocityY = 0;
                    state.isGrounded = true;
                }
            } else {
                // Player is falling
                state.isGrounded = false;
                state.velocityY += gravity * delta;
                camera.position.y += state.velocityY * delta;
            }

            // Check if player is falling (Y < -15 means fell through hole)
            if (camera.position.y < -15) {
                handleTeleport();
            }

            // Check if player reached exit door (escaped)
            // Exit door appears at z=-250 after 3 correct choices
            if (camera.position.z < -249 && correctPathCount >= 3) {
                state.escaped = true;
                showEscapeScreen();
            }
        }

        // ===========================
        // HANDLE TELEPORT AFTER FALLING
        // ===========================
        function handleTeleport() {
            // Clean up all current checkpoints and their geometry
            checkpoints.forEach(checkpoint => {
                if (checkpoint.exitPanel) scene.remove(checkpoint.exitPanel);
                if (checkpoint.leftDoor) scene.remove(checkpoint.leftDoor);
                if (checkpoint.rightDoor) scene.remove(checkpoint.rightDoor);
                if (checkpoint.leftBlock) scene.remove(checkpoint.leftBlock);
                if (checkpoint.rightBlock) scene.remove(checkpoint.rightBlock);
                if (checkpoint.backWall) scene.remove(checkpoint.backWall);
                if (checkpoint.connectorWalls) {
                    checkpoint.connectorWalls.forEach(wall => scene.remove(wall));
                }
            });
            checkpoints = [];

            // Reset player position to start of new segment
            camera.position.set(0, 0, 50);
            camera.rotation.set(0, 0, 0);

            // Reset falling state
            state.velocityY = 0;
            state.isGrounded = true;

            // Reset checkpoint generation
            nextCheckpointZ = -50; // First checkpoint 100 units ahead
            lastWallEndZ = 50;

            // Generate new checkpoints (one checkpoint = one choice point)
            generateCheckpoint();

            // Increase correct path count (player successfully fell through)
            correctPathCount++;

            // Check if player has won (3 successful falls)
            if (correctPathCount >= 3) {
                state.escaped = true;
                showEscapeScreen();
                return;
            }

            console.log(`Teleported! Progress: ${correctPathCount}/3`);
        }

        // ===========================
        // UPDATE MONSTERS (CLUSTERS)
        // ===========================
        function updateMonsters(delta) {
            const time = Date.now() * 0.001;
            const currentMode = modes[state.currentMode];

            for (let i = monsters.length - 1; i >= 0; i--) {
                const monsterCluster = monsters[i];
                const userData = monsterCluster.userData;

                // Check if monster is hit by flashlight
                const isHitByFlashlight = checkFlashlightHit(monsterCluster);

                // Handle freeze timer
                if (userData.frozen && userData.freezeTimer > 0) {
                    userData.freezeTimer -= delta;
                    if (userData.freezeTimer <= 0) {
                        userData.frozen = false;
                    }
                }

                // Apply flashlight effects based on mode
                if (isHitByFlashlight) {
                    // Mode 0: Wide Beam (Orange) - Freezes all monsters
                    if (state.currentMode === 0) {
                        if (!userData.frozen) {
                            userData.frozen = true;
                            userData.freezeTimer = 2.0; // Freeze for 2 seconds
                            playStaticClick();
                        }
                    }

                    // Mode 1: Detection (Green) - Disintegrates green monsters
                    else if (state.currentMode === 1 && userData.type === 'green') {
                        if (!userData.disintegrating) {
                            userData.disintegrating = true;
                            userData.disintegrateTime = time;
                            playDetectionNoise();
                        }
                    }
                }

                // Handle disintegration
                if (userData.disintegrating) {
                    const disintegrateProgress = (time - userData.disintegrateTime) / 2.0; // 2 seconds to disintegrate
                    if (disintegrateProgress >= 1.0) {
                        // Remove completely disintegrated monster
                        scene.remove(monsterCluster);
                        monsters.splice(i, 1);
                        continue;
                    }

                    // Fade out and break apart
                    monsterCluster.children.forEach((sprite, index) => {
                        sprite.material.opacity *= (1 - disintegrateProgress);
                        sprite.position.y += disintegrateProgress * 0.1;
                    });
                }

                // Move cluster slowly towards player (only if not frozen)
                if (!userData.frozen && !userData.disintegrating) {
                    const directionToPlayer = new THREE.Vector3();
                    directionToPlayer.subVectors(camera.position, monsterCluster.position);
                    directionToPlayer.y = 0; // Only move horizontally
                    directionToPlayer.normalize();

                    monsterCluster.position.x += directionToPlayer.x * userData.approachSpeed;
                    monsterCluster.position.z += directionToPlayer.z * userData.approachSpeed;
                }

                // Slow rotation of entire cluster (slower when frozen)
                const rotationSpeed = userData.frozen ? userData.rotationSpeed * 0.1 : userData.rotationSpeed;
                monsterCluster.rotation.y += rotationSpeed * delta;

                // Pulse opacity of entire cluster
                const pulseFactor = Math.sin(time * 1.5 + userData.pulsePhase) * 0.2;

                // Animate individual text fragments within cluster
                monsterCluster.children.forEach((sprite, index) => {
                    if (userData.disintegrating) return; // Skip normal animation if disintegrating

                    // Individual floating motion
                    sprite.position.y += Math.sin(time * sprite.userData.floatSpeed + sprite.userData.floatOffset) * 0.005;

                    // Adjust opacity based on state
                    let targetOpacity;
                    if (userData.type === 'green') {
                        // Green monsters: nearly invisible unless revealed
                        targetOpacity = userData.revealed ? 0.8 : 0.1;
                    } else {
                        // Red monsters: visible, more visible when revealed
                        targetOpacity = userData.revealed ? 1.0 : (userData.baseOpacity + pulseFactor);
                    }

                    // Apply freeze effect (red tint)
                    if (userData.frozen) {
                        sprite.material.color.setHex(0xff0000); // Red tint when frozen
                    } else {
                        sprite.material.color.setHex(0xffffff); // Normal color
                    }

                    sprite.material.opacity = targetOpacity + Math.sin(time * 2 + index) * 0.1;

                    // Slight rotation for each fragment
                    sprite.rotation.z = Math.sin(time * 0.5 + index) * 0.1;
                });

                // Check if monster hits player
                const distanceToPlayer = monsterCluster.position.distanceTo(camera.position);
                if (distanceToPlayer < 2) {
                    // Monster hit the player!
                    const currentTime = Date.now() * 0.001;
                    if (currentTime - state.lastHitTime > state.invulnerableTime) {
                        playerHit();
                        state.lastHitTime = currentTime;
                    }
                    // Remove monster after hit
                    scene.remove(monsterCluster);
                    monsters.splice(i, 1);
                    continue;
                }

                // Remove if too far
                if (distanceToPlayer > 500) {
                    scene.remove(monsterCluster);
                    monsters.splice(i, 1);
                }
            }
        }

        // ===========================
        // CHECK FLASHLIGHT HIT
        // ===========================
        function checkFlashlightHit(monsterCluster) {
            // Get monster position relative to camera
            const monsterPos = new THREE.Vector3();
            monsterPos.copy(monsterCluster.position);

            // Transform to camera space
            const cameraToMonster = new THREE.Vector3();
            cameraToMonster.subVectors(monsterPos, camera.position);

            // Get distance
            const distance = cameraToMonster.length();

            // Get current mode settings
            const mode = modes[state.currentMode];

            // Check if within flashlight distance
            if (distance > mode.distance) return false;

            // Get direction camera is looking
            const cameraDirection = new THREE.Vector3(0, 0, -1);
            cameraDirection.applyQuaternion(camera.quaternion);

            // Calculate angle between camera direction and monster direction
            cameraToMonster.normalize();
            const angle = Math.acos(cameraDirection.dot(cameraToMonster));

            // Check if within spotlight cone angle
            return angle < mode.angle;
        }

        // ===========================
        // AUDIO FEEDBACK
        // ===========================
        function playStaticClick() {
            // Simple click sound feedback
            if (state.audioContext) {
                const oscillator = state.audioContext.createOscillator();
                const gainNode = state.audioContext.createGain();
                oscillator.frequency.value = 800;
                oscillator.type = 'square';
                gainNode.gain.setValueAtTime(0.1, state.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.1);
                oscillator.connect(gainNode);
                gainNode.connect(state.audioContext.destination);
                oscillator.start();
                oscillator.stop(state.audioContext.currentTime + 0.1);
            }
        }

        function playDetectionNoise() {
            // Detection sound feedback
            if (state.audioContext) {
                const oscillator = state.audioContext.createOscillator();
                const gainNode = state.audioContext.createGain();
                oscillator.frequency.value = 1200;
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.15, state.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.2);
                oscillator.connect(gainNode);
                gainNode.connect(state.audioContext.destination);
                oscillator.start();
                oscillator.stop(state.audioContext.currentTime + 0.2);
            }
        }

        // Initialize audio context
        function initAudio() {
            try {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn('Web Audio API not supported');
            }
        }

        // ===========================
        // PLAYER HIT & DAMAGE SYSTEM
        // ===========================
        function playerHit() {
            if (state.isGameOver) return;

            state.hitCount++;
            console.log(`Hit! Count: ${state.hitCount}/${state.maxHits}`);

            // Trigger hit effect
            triggerHitEffect();

            // Update BUG invasion UI
            updateBugInvasion();

            // Play hit sound
            playHitSound();

            // Check for game over
            if (state.hitCount >= state.maxHits) {
                triggerGameOver();
            }
        }

        // Trigger visual hit effect
        function triggerHitEffect() {
            const hitFlash = document.getElementById('hit-flash');

            // Flash red
            hitFlash.classList.add('flash-hit');
            setTimeout(() => {
                hitFlash.classList.remove('flash-hit');
            }, 200);

            // Camera shake effect
            const originalY = camera.rotation.y;
            const originalX = camera.rotation.x;
            const shakeAmount = 0.1;

            // Quick shake
            camera.rotation.x += (Math.random() - 0.5) * shakeAmount;
            camera.rotation.y += (Math.random() - 0.5) * shakeAmount;

            setTimeout(() => {
                camera.rotation.x = originalX;
                camera.rotation.y = originalY;
            }, 100);
        }

        // Update BUG text invasion - random scattered all over edges
        function updateBugInvasion() {
            const container = document.getElementById('bug-invasion');

            // Calculate how many BUGs to add (exponential growth)
            // Hit 1: 15 bugs, Hit 2: 30 bugs, ..., Hit 10: 150 bugs total
            const totalBugs = state.hitCount * 15;

            // Remove existing bugs
            container.innerHTML = '';

            // Generate random BUG texts all over the screen edges
            for (let i = 0; i < totalBugs; i++) {
                const bugElement = document.createElement('div');
                bugElement.className = 'bug-text';
                bugElement.textContent = 'BUG';

                // Random font size (10px - 30px)
                const fontSize = 10 + Math.random() * 20;
                bugElement.style.fontSize = fontSize + 'px';

                // Random rotation (-30deg to 30deg)
                const rotation = (Math.random() - 0.5) * 60;
                bugElement.style.transform = `rotate(${rotation}deg)`;

                // Decide which edge to place it on
                const edge = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left

                // Progress factor: how far into the screen bugs should penetrate
                // 0 at hit 0, 1.0 at hit 10
                const penetration = (state.hitCount / state.maxHits);

                let x, y;

                if (edge === 0) {
                    // Top edge
                    x = Math.random() * 100; // 0-100%
                    y = Math.random() * 40 * penetration; // Penetrate into screen
                    bugElement.style.left = x + '%';
                    bugElement.style.top = y + '%';
                } else if (edge === 1) {
                    // Right edge
                    x = 100 - Math.random() * 40 * penetration;
                    y = Math.random() * 100;
                    bugElement.style.left = x + '%';
                    bugElement.style.top = y + '%';
                } else if (edge === 2) {
                    // Bottom edge
                    x = Math.random() * 100;
                    y = 100 - Math.random() * 40 * penetration;
                    bugElement.style.left = x + '%';
                    bugElement.style.top = y + '%';
                } else {
                    // Left edge
                    x = Math.random() * 40 * penetration;
                    y = Math.random() * 100;
                    bugElement.style.left = x + '%';
                    bugElement.style.top = y + '%';
                }

                // Random animation delay for staggered glitch effect
                bugElement.style.animationDelay = (Math.random() * 0.3) + 's';

                container.appendChild(bugElement);
            }
        }

        // Play hit sound
        function playHitSound() {
            if (!state.audioContext) return;

            // Harsh alarm sound
            const oscillator = state.audioContext.createOscillator();
            const gainNode = state.audioContext.createGain();

            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(200, state.audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, state.audioContext.currentTime + 0.3);

            gainNode.gain.setValueAtTime(0.3, state.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.3);

            oscillator.connect(gainNode);
            gainNode.connect(state.audioContext.destination);

            oscillator.start();
            oscillator.stop(state.audioContext.currentTime + 0.3);
        }

        // Trigger game over
        function triggerGameOver() {
            state.isGameOver = true;

            // Show game over screen
            document.getElementById('game-over').classList.add('show');

            // Release pointer lock
            document.exitPointerLock();

            // Play game over sound
            playGameOverSound();
        }

        // Show escape success screen
        function showEscapeScreen() {
            if (state.isGameOver) return; // Don't override game over

            console.log('ðŸŽ‰ ESCAPED - You found the EXIT!');

            // Show escape success screen
            document.getElementById('escape-screen').classList.add('show');

            // Release pointer lock
            document.exitPointerLock();

            // Play success sound
            playEscapeSound();
        }

        // Play game over sound
        function playGameOverSound() {
            if (!state.audioContext) return;

            // Dramatic descending tone
            const oscillator = state.audioContext.createOscillator();
            const gainNode = state.audioContext.createGain();

            oscillator.type = 'square';
            oscillator.frequency.setValueAtTime(800, state.audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(100, state.audioContext.currentTime + 1.5);

            gainNode.gain.setValueAtTime(0.4, state.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 1.5);

            oscillator.connect(gainNode);
            gainNode.connect(state.audioContext.destination);

            oscillator.start();
            oscillator.stop(state.audioContext.currentTime + 1.5);
        }

        // Play escape success sound
        function playEscapeSound() {
            if (!state.audioContext) return;

            // Triumphant ascending tone
            const oscillator = state.audioContext.createOscillator();
            const gainNode = state.audioContext.createGain();

            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(200, state.audioContext.currentTime);
            oscillator.frequency.exponentialRampToValueAtTime(800, state.audioContext.currentTime + 0.8);

            gainNode.gain.setValueAtTime(0.3, state.audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, state.audioContext.currentTime + 0.8);

            oscillator.connect(gainNode);
            gainNode.connect(state.audioContext.destination);

            oscillator.start();
            oscillator.stop(state.audioContext.currentTime + 0.8);
        }

        // ===========================
        // ANIMATION LOOP
        // ===========================
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Stop updates if game over or escaped
            if (!state.isGameOver && !state.escaped) {
                updateMovement(delta);
                updateMonsters(delta);
                checkCheckpoints(); // Check if player is at a checkpoint
                updateCheckpointEffects(delta); // Update checkpoint lights and EXIT panels

                // No auto-generation - each segment has only one checkpoint (end point)
                // Player must choose left or right, fall through, and teleport to next segment
            }

            // Animate flowing text like code stream
            const time = Date.now() * 0.001;
            if (wallTextures.length >= 4) {
                // Right and left walls: flow along corridor (faster)
                wallTextures[0].offset.x = (time * 0.25) % 1; // Right wall - faster flow
                wallTextures[1].offset.x = (time * 0.25) % 1; // Left wall
                wallTextures[0].needsUpdate = true;
                wallTextures[1].needsUpdate = true;

                // Ceiling and floor: flow horizontally (faster)
                wallTextures[2].offset.y = (time * 0.35) % 1; // Ceiling
                wallTextures[3].offset.y = (time * 0.35) % 1; // Floor
                wallTextures[2].needsUpdate = true;
                wallTextures[3].needsUpdate = true;
            }

            // Random flicker
            if (Math.random() > 0.995) {
                const mode = modes[state.currentMode];
                spotlight.intensity = mode.intensity * 0.7;
                setTimeout(() => {
                    spotlight.intensity = mode.intensity;
                }, 100);
            }

            renderer.render(scene, camera);
        }

        // ===========================
        // WINDOW RESIZE
        // ===========================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===========================
        // INITIALIZE
        // ===========================
        window.addEventListener('load', () => {
            console.log('ðŸ”¦ 3D Corridor Flashlight Loading...');
            init();
            console.log('âœ… 3D Scene Ready!');
        });
    </script>
</body>
</html>
