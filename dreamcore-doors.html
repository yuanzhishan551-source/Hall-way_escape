<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dreamcore: Between Doors</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Georgia', serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        #canvas-container:active {
            cursor: grabbing;
        }

        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 100;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 5px;
        }

        #transition-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 1000;
            transition: opacity 1.5s ease;
        }

        #transition-overlay.active {
            opacity: 1;
        }

        #world-title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.9);
            font-size: 32px;
            z-index: 150;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            font-weight: 300;
            letter-spacing: 4px;
        }

        #world-title.show {
            animation: fadeInOut 4s ease;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 200;
        }

        @media (max-width: 768px) {
            #ui-overlay {
                font-size: 12px;
                padding: 10px;
            }
            #world-title {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div id="loading">Loading dreamcore...</div>
    <div id="ui-overlay">
        <div id="instructions">
            WASD / Arrow Keys: Move<br>
            Mouse Drag: Look Around<br>
            Scroll: Zoom<br>
            Approach doors to enter new worlds
        </div>
        <div id="current-world" style="margin-top: 15px; font-style: italic; color: rgba(200, 180, 255, 0.8);">
            World: The Hallway
        </div>
    </div>
    <div id="world-title"></div>
    <div id="transition-overlay"></div>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        window.addEventListener('load', function() {
            init();
        });

        function init() {
            // Scene
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.FogExp2(0x8b9dc3, 0.015);

            // Camera
            const camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1.6, 8);

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            document.getElementById('loading').style.display = 'none';

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xb8c6db, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffd4e5, 0.8);
            directionalLight.position.set(10, 20, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Point lights for dreamcore atmosphere
            const pointLight1 = new THREE.PointLight(0xff9999, 1, 30);
            pointLight1.position.set(-10, 5, -10);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x99ccff, 1, 30);
            pointLight2.position.set(10, 5, 10);
            scene.add(pointLight2);

            // Create ground
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4d4e8,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Texture loader
            const textureLoader = new THREE.TextureLoader();

            // Door creation function
            function createDoor(textureUrl, position, name, worldIndex) {
                const doorGroup = new THREE.Group();

                // Door frame
                const frameGeometry = new THREE.BoxGeometry(2.2, 3.2, 0.2);
                const frameMaterial = new THREE.MeshStandardMaterial({
                    color: 0x8b7355,
                    roughness: 0.7,
                    metalness: 0.3
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.castShadow = true;
                frame.receiveShadow = true;
                doorGroup.add(frame);

                // Door itself
                const doorGeometry = new THREE.BoxGeometry(2, 3, 0.15);
                const doorMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.5,
                    metalness: 0.1
                });

                const door = new THREE.Mesh(doorGeometry, doorMaterial);
                door.position.z = 0.05;
                door.castShadow = true;
                door.receiveShadow = true;

                // Load texture
                textureLoader.load(
                    textureUrl,
                    (texture) => {
                        doorMaterial.map = texture;
                        doorMaterial.needsUpdate = true;
                    },
                    undefined,
                    (error) => {
                        console.log('Texture loading failed, using color');
                        // Create a gradient canvas texture as fallback
                        const canvas = document.createElement('canvas');
                        canvas.width = 512;
                        canvas.height = 512;
                        const ctx = canvas.getContext('2d');
                        const gradient = ctx.createLinearGradient(0, 0, 512, 512);
                        gradient.addColorStop(0, worldIndex === 0 ? '#8b4513' : '#4a5568');
                        gradient.addColorStop(1, worldIndex === 0 ? '#d2691e' : '#718096');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 512, 512);
                        const fallbackTexture = new THREE.CanvasTexture(canvas);
                        doorMaterial.map = fallbackTexture;
                        doorMaterial.needsUpdate = true;
                    }
                );

                doorGroup.add(door);

                // Glow effect
                const glowGeometry = new THREE.PlaneGeometry(2.5, 3.5);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: worldIndex === 0 ? 0xffd700 : 0x87ceeb,
                    transparent: true,
                    opacity: 0,
                    side: THREE.DoubleSide
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                glow.position.z = -0.1;
                doorGroup.add(glow);

                doorGroup.position.copy(position);
                doorGroup.userData = {
                    name: name,
                    worldIndex: worldIndex,
                    door: door,
                    glow: glow,
                    isOpen: false,
                    openProgress: 0,
                    glowIntensity: 0
                };

                return doorGroup;
            }

            // Create doors
            const doors = [];

            // Door 1 - Wooden door
            const door1 = createDoor(
                'https://m.media-amazon.com/images/I/612SFrHTMNL._AC_SL1500_.jpg',
                new THREE.Vector3(-5, 1.5, -10),
                'The Infinite Corridor',
                0
            );
            scene.add(door1);
            doors.push(door1);

            // Door 2 - Modern door
            const door2 = createDoor(
                'https://m.media-amazon.com/images/I/615KKqEE5dL._AC_SL1500_.jpg',
                new THREE.Vector3(5, 1.5, -10),
                'The Floating Gardens',
                1
            );
            scene.add(door2);
            doors.push(door2);

            // Door 3 - Dream door (white)
            const door3 = createDoor(
                '',
                new THREE.Vector3(0, 1.5, -15),
                'The Void Between',
                2
            );
            scene.add(door3);
            doors.push(door3);

            // Environmental objects
            function createFloatingClock() {
                const clockGroup = new THREE.Group();

                // Clock face
                const faceGeometry = new THREE.CircleGeometry(0.5, 32);
                const faceMaterial = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    roughness: 0.3,
                    metalness: 0.7
                });
                const face = new THREE.Mesh(faceGeometry, faceMaterial);
                clockGroup.add(face);

                // Clock hands
                const handGeometry = new THREE.BoxGeometry(0.05, 0.3, 0.02);
                const handMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
                const hourHand = new THREE.Mesh(handGeometry, handMaterial);
                hourHand.position.y = 0.1;
                clockGroup.add(hourHand);

                const minuteHand = new THREE.Mesh(new THREE.BoxGeometry(0.03, 0.4, 0.02), handMaterial);
                minuteHand.position.y = 0.15;
                clockGroup.add(minuteHand);

                clockGroup.userData = {
                    floatOffset: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.5,
                    hourHand: hourHand,
                    minuteHand: minuteHand
                };

                return clockGroup;
            }

            function createTV() {
                const tvGroup = new THREE.Group();

                // TV body
                const bodyGeometry = new THREE.BoxGeometry(1.5, 1, 0.3);
                const bodyMaterial = new THREE.MeshStandardMaterial({
                    color: 0x2c2c2c,
                    roughness: 0.5,
                    metalness: 0.5
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                tvGroup.add(body);

                // Screen
                const screenGeometry = new THREE.PlaneGeometry(1.3, 0.8);
                const screenMaterial = new THREE.MeshBasicMaterial({
                    color: 0x4a90e2,
                    emissive: 0x4a90e2,
                    emissiveIntensity: 0.5
                });
                const screen = new THREE.Mesh(screenGeometry, screenMaterial);
                screen.position.z = 0.16;
                tvGroup.add(screen);

                tvGroup.userData = {
                    screen: screen,
                    flickerPhase: Math.random() * Math.PI * 2
                };

                return tvGroup;
            }

            // Add environmental objects
            const environmentalObjects = [];

            for (let i = 0; i < 5; i++) {
                const clock = createFloatingClock();
                clock.position.set(
                    (Math.random() - 0.5) * 40,
                    2 + Math.random() * 3,
                    (Math.random() - 0.5) * 40
                );
                clock.rotation.y = Math.random() * Math.PI * 2;
                scene.add(clock);
                environmentalObjects.push(clock);
            }

            for (let i = 0; i < 3; i++) {
                const tv = createTV();
                tv.position.set(
                    (Math.random() - 0.5) * 30,
                    1 + Math.random() * 2,
                    (Math.random() - 0.5) * 30 - 5
                );
                tv.rotation.y = Math.random() * Math.PI * 2;
                scene.add(tv);
                environmentalObjects.push(tv);
            }

            // Particle system for atmosphere
            const particleCount = 200;
            const particleGeometry = new THREE.BufferGeometry();
            const particlePositions = [];
            const particleVelocities = [];

            for (let i = 0; i < particleCount; i++) {
                particlePositions.push(
                    (Math.random() - 0.5) * 100,
                    Math.random() * 20,
                    (Math.random() - 0.5) * 100
                );
                particleVelocities.push(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02
                );
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particlePositions, 3));

            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.1,
                transparent: true,
                opacity: 0.6,
                sizeAttenuation: true
            });

            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);

            // World data
            const worlds = [
                {
                    name: 'The Infinite Corridor',
                    fogColor: 0xff9999,
                    bgColor: 0x2e1a1a,
                    gravity: new THREE.Vector3(0, 0, -0.1)
                },
                {
                    name: 'The Floating Gardens',
                    fogColor: 0x99ffcc,
                    bgColor: 0x1a2e2e,
                    gravity: new THREE.Vector3(0, 0.05, 0)
                },
                {
                    name: 'The Void Between',
                    fogColor: 0xccccff,
                    bgColor: 0x0a0a1a,
                    gravity: new THREE.Vector3(0, 0, 0)
                }
            ];

            let currentWorld = -1;

            // Controls
            const state = {
                moveForward: false,
                moveBackward: false,
                moveLeft: false,
                moveRight: false,
                velocity: new THREE.Vector3(),
                direction: new THREE.Vector3(),
                mouseX: 0,
                mouseY: 0,
                isDragging: false,
                zoom: 0
            };

            document.addEventListener('keydown', (e) => {
                switch (e.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        state.moveForward = true;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        state.moveBackward = true;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        state.moveLeft = true;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        state.moveRight = true;
                        break;
                }
            });

            document.addEventListener('keyup', (e) => {
                switch (e.code) {
                    case 'KeyW':
                    case 'ArrowUp':
                        state.moveForward = false;
                        break;
                    case 'KeyS':
                    case 'ArrowDown':
                        state.moveBackward = false;
                        break;
                    case 'KeyA':
                    case 'ArrowLeft':
                        state.moveLeft = false;
                        break;
                    case 'KeyD':
                    case 'ArrowRight':
                        state.moveRight = false;
                        break;
                }
            });

            // Mouse/Touch controls
            let lastTouchX = 0, lastTouchY = 0;

            renderer.domElement.addEventListener('mousedown', (e) => {
                state.isDragging = true;
            });

            document.addEventListener('mouseup', () => {
                state.isDragging = false;
            });

            document.addEventListener('mousemove', (e) => {
                if (state.isDragging) {
                    const movementX = e.movementX || 0;
                    const movementY = e.movementY || 0;

                    camera.rotation.y -= movementX * 0.002;
                    camera.rotation.x -= movementY * 0.002;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
                }
            });

            // Touch controls
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                    state.isDragging = true;
                }
            });

            renderer.domElement.addEventListener('touchmove', (e) => {
                if (e.touches.length === 1 && state.isDragging) {
                    const deltaX = e.touches[0].clientX - lastTouchX;
                    const deltaY = e.touches[0].clientY - lastTouchY;

                    camera.rotation.y -= deltaX * 0.005;
                    camera.rotation.x -= deltaY * 0.005;
                    camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));

                    lastTouchX = e.touches[0].clientX;
                    lastTouchY = e.touches[0].clientY;
                }
                e.preventDefault();
            }, { passive: false });

            renderer.domElement.addEventListener('touchend', () => {
                state.isDragging = false;
            });

            // Zoom
            document.addEventListener('wheel', (e) => {
                state.zoom += e.deltaY * 0.001;
                state.zoom = Math.max(-5, Math.min(5, state.zoom));
            }, { passive: true });

            // Calculate door screen coverage
            function calculateDoorScreenCoverage(doorGroup) {
                const doorPosition = new THREE.Vector3();
                doorGroup.getWorldPosition(doorPosition);

                const distance = camera.position.distanceTo(doorPosition);

                // Calculate direction to door
                const directionToDoor = new THREE.Vector3();
                directionToDoor.subVectors(doorPosition, camera.position).normalize();

                // Camera forward direction
                const cameraDirection = new THREE.Vector3(0, 0, -1);
                cameraDirection.applyQuaternion(camera.quaternion);

                // Calculate angle
                const angle = cameraDirection.angleTo(directionToDoor);

                // Screen coverage based on distance and angle
                const angularSize = 3 / distance; // Approximate door size
                const coverage = Math.max(0, (1 - angle / (Math.PI / 4)) * angularSize * 100);

                return { coverage, distance, angle };
            }

            // Transition to new world
            function transitionToWorld(worldIndex, doorGroup) {
                const overlay = document.getElementById('transition-overlay');
                const titleElement = document.getElementById('world-title');

                overlay.classList.add('active');

                setTimeout(() => {
                    // Change world
                    currentWorld = worldIndex;
                    const world = worlds[worldIndex];

                    scene.background = new THREE.Color(world.bgColor);
                    scene.fog.color = new THREE.Color(world.fogColor);

                    // Update UI
                    document.getElementById('current-world').textContent = `World: ${world.name}`;

                    // Show title
                    titleElement.textContent = world.name;
                    titleElement.classList.add('show');

                    setTimeout(() => {
                        titleElement.classList.remove('show');
                    }, 4000);

                    // Move camera through door
                    const doorPos = new THREE.Vector3();
                    doorGroup.getWorldPosition(doorPos);
                    camera.position.set(doorPos.x, doorPos.y, doorPos.z + 3);

                    overlay.classList.remove('active');
                }, 1500);
            }

            // Animation
            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);

                const delta = clock.getDelta();
                const time = clock.getElapsedTime();

                // Movement
                const speed = 3.0;

                state.velocity.x -= state.velocity.x * 8.0 * delta;
                state.velocity.z -= state.velocity.z * 8.0 * delta;

                state.direction.z = Number(state.moveForward) - Number(state.moveBackward);
                state.direction.x = Number(state.moveRight) - Number(state.moveLeft);
                state.direction.normalize();

                if (state.moveForward || state.moveBackward) {
                    state.velocity.z -= state.direction.z * speed * delta;
                }
                if (state.moveLeft || state.moveRight) {
                    state.velocity.x += state.direction.x * speed * delta;
                }

                const moveX = state.velocity.x * Math.cos(camera.rotation.y) - state.velocity.z * Math.sin(camera.rotation.y);
                const moveZ = state.velocity.x * Math.sin(camera.rotation.y) + state.velocity.z * Math.cos(camera.rotation.y);

                camera.position.x += moveX;
                camera.position.z += moveZ;

                // Apply zoom
                camera.fov = 75 - state.zoom * 5;
                camera.updateProjectionMatrix();

                // Update doors
                doors.forEach((doorGroup) => {
                    const { coverage, distance } = calculateDoorScreenCoverage(doorGroup);
                    const userData = doorGroup.userData;

                    // Glow effect based on proximity
                    if (coverage > 20) {
                        userData.glowIntensity = Math.min(1, userData.glowIntensity + delta * 2);
                    } else {
                        userData.glowIntensity = Math.max(0, userData.glowIntensity - delta);
                    }

                    userData.glow.material.opacity = userData.glowIntensity * 0.3;

                    // Door opening animation at 80% coverage
                    if (coverage > 80 && !userData.isOpen) {
                        userData.isOpen = true;
                        userData.openProgress = 0;
                    }

                    if (userData.isOpen && userData.openProgress < 1) {
                        userData.openProgress = Math.min(1, userData.openProgress + delta * 0.5);

                        // Swing door open
                        userData.door.rotation.y = -Math.PI / 2 * userData.openProgress;

                        // Increase glow
                        userData.glow.material.opacity = userData.openProgress * 0.8;

                        // Transport when fully open
                        if (userData.openProgress >= 1 && distance < 2) {
                            transitionToWorld(userData.worldIndex, doorGroup);
                            userData.isOpen = false;
                            userData.openProgress = 0;
                        }
                    }

                    // Pulse glow
                    userData.glow.material.opacity += Math.sin(time * 2) * 0.05 * userData.glowIntensity;
                });

                // Animate environmental objects
                environmentalObjects.forEach((obj) => {
                    if (obj.userData.hourHand) {
                        // Clock
                        const floatY = Math.sin(time * 0.5 + obj.userData.floatOffset) * 0.3;
                        obj.position.y += floatY * delta;
                        obj.rotation.z += obj.userData.rotationSpeed * delta;
                        obj.userData.hourHand.rotation.z = time * 0.1;
                        obj.userData.minuteHand.rotation.z = time * 0.5;
                    } else if (obj.userData.screen) {
                        // TV
                        const flicker = Math.sin(time * 10 + obj.userData.flickerPhase) * 0.5 + 0.5;
                        obj.userData.screen.material.emissiveIntensity = 0.3 + flicker * 0.4;
                    }
                });

                // Animate particles
                const positions = particles.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;
                    positions[i3] += particleVelocities[i3];
                    positions[i3 + 1] += particleVelocities[i3 + 1];
                    positions[i3 + 2] += particleVelocities[i3 + 2];

                    // Wrap around
                    if (Math.abs(positions[i3]) > 50) positions[i3] *= -0.9;
                    if (positions[i3 + 1] > 20 || positions[i3 + 1] < 0) particleVelocities[i3 + 1] *= -1;
                    if (Math.abs(positions[i3 + 2]) > 50) positions[i3 + 2] *= -0.9;
                }
                particles.geometry.attributes.position.needsUpdate = true;

                // Animate lights
                pointLight1.intensity = 1 + Math.sin(time * 0.5) * 0.3;
                pointLight2.intensity = 1 + Math.cos(time * 0.7) * 0.3;

                renderer.render(scene, camera);
            }

            animate();

            // Resize handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
    </script>
</body>
</html>
